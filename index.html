<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WebGL e Transformações Lineares</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:wght@400;500;600;700&family=IBM+Plex+Sans:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    :root {
      --primary: #1e3a8a;
      --primary-light: #3b82f6;
      --accent: #0f172a;
      --gold: #b8860b;
      --bg-white: #ffffff;
      --bg-light: #f8fafc;
      --bg-cream: #fefdfb;
      --text-primary: #0f172a;
      --text-secondary: #475569;
      --text-muted: #64748b;
      --border: #e2e8f0;
      --border-dark: #cbd5e1;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'IBM Plex Sans', -apple-system, system-ui, sans-serif;
      background: var(--bg-cream);
      color: var(--text-primary);
      line-height: 1.75;
      -webkit-font-smoothing: antialiased;
    }

    /* Progress Bar */
    .progress-bar {
      position: fixed;
      top: 0;
      left: 0;
      height: 3px;
      background: var(--primary);
      width: 0%;
      z-index: 1000;
      transition: width 0.1s ease;
    }

    /* Table of Contents Sidebar */
    .toc-sidebar {
      position: fixed;
      left: 0;
      top: 0;
      width: 280px;
      height: 100vh;
      background: var(--bg-white);
      border-right: 1px solid var(--border);
      overflow-y: auto;
      padding: 2rem 0;
      z-index: 100;
      transition: transform 0.3s ease, width 0.3s ease;
    }

    .toc-sidebar.collapsed {
      transform: translateX(-280px);
    }

    .toc-header {
      padding: 0 1.5rem 1rem;
      border-bottom: 1px solid var(--border);
      margin-bottom: 1rem;
    }

    .toc-title {
      font-family: 'IBM Plex Serif', serif;
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-primary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .toc-progress {
      margin-top: 0.75rem;
      height: 4px;
      background: var(--bg-light);
      border-radius: 2px;
      overflow: hidden;
    }

    .toc-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary), var(--primary-light));
      width: 0%;
      transition: width 0.2s ease;
      border-radius: 2px;
    }

    .toc-nav {
      padding: 1rem 0;
    }

    .toc-item {
      position: relative;
      padding: 0.5rem 1.5rem;
      font-family: 'IBM Plex Sans', sans-serif;
      font-size: 0.875rem;
      color: var(--text-secondary);
      text-decoration: none;
      display: block;
      transition: all 0.2s ease;
      border-left: 3px solid transparent;
      line-height: 1.4;
    }

    .toc-item:hover {
      color: var(--primary);
      background: var(--bg-light);
    }

    .toc-item.active {
      color: var(--primary);
      background: var(--bg-light);
      border-left-color: var(--primary);
      font-weight: 500;
    }

    .toc-item-number {
      display: inline-block;
      min-width: 1.5rem;
      color: var(--text-muted);
      font-weight: 600;
      font-size: 0.8125rem;
    }

    .toc-subsection {
      padding-left: 3rem;
      font-size: 0.8125rem;
    }

    .toc-toggle {
      display: none;
      position: fixed;
      top: 1rem;
      left: 1rem;
      z-index: 101;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 6px;
      padding: 0.5rem 0.75rem;
      cursor: pointer;
      font-size: 1.25rem;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .toc-toggle:hover {
      background: var(--primary-light);
    }

    .toc-collapse-btn {
      position: fixed;
      left: 290px;
      top: 1rem;
      z-index: 101;
      background: var(--bg-white);
      color: var(--primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem 0.75rem;
      cursor: pointer;
      font-size: 1.25rem;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      transition: left 0.3s ease;
    }

    .toc-collapse-btn:hover {
      background: var(--bg-light);
      border-color: var(--primary);
    }

    .toc-collapse-btn.collapsed {
      left: 1rem;
    }

    body.has-toc.sidebar-collapsed {
      margin-left: 0;
    }

    /* Institutional Header */
    .institutional-header {
      background: var(--bg-white);
      border-bottom: 3px solid var(--primary);
      padding: 1.5rem 2rem;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .institutional-info {
      max-width: 1100px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .institution-name {
      font-family: 'IBM Plex Serif', serif;
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--primary);
      letter-spacing: 0.05em;
      text-transform: uppercase;
      line-height: 1.4;
    }

    .course-info {
      font-size: 0.8125rem;
      color: var(--text-secondary);
      text-align: right;
    }

    /* Main Header */
    header {
      background: var(--bg-white);
      padding: 4rem 2rem 3rem;
      text-align: center;
      border-bottom: 1px solid var(--border);
    }

    .header-category {
      display: inline-block;
      font-family: 'IBM Plex Sans', sans-serif;
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--text-muted);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid var(--gold);
    }

    header h1 {
      font-family: 'IBM Plex Serif', serif;
      font-size: clamp(2rem, 4vw, 3rem);
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 1.25rem;
      letter-spacing: -0.01em;
      line-height: 1.2;
    }

    .header-subtitle {
      font-family: 'IBM Plex Serif', serif;
      font-size: 1.25rem;
      font-weight: 400;
      color: var(--text-secondary);
      font-style: italic;
      max-width: 700px;
      margin: 0 auto 2rem;
      line-height: 1.6;
    }

    /* Footer */
    footer {
      border-top: 2px solid var(--border-dark);
      padding: 2.5rem 2rem;
      margin-top: 4rem;
      text-align: center;
    }

    .footer-content {
      max-width: 800px;
      margin: 0 auto;
    }

    footer .author-info {
      display: inline-block;
      margin: 0 1.5rem 0.5rem;
      font-size: 1rem;
      color: var(--text-primary);
    }

    footer .author-info strong {
      font-weight: 600;
    }

    .footer-institution {
      margin-top: 1.25rem;
      padding-top: 1.25rem;
      border-top: 1px solid var(--border-dark);
      font-size: 0.9375rem;
      color: var(--text-primary);
      font-weight: 600;
    }

    /* Main Container */
    body.has-toc {
      margin-left: 280px;
    }

    main {
      max-width: 800px;
      margin: 0 auto;
      padding: 4rem 2rem;
      background: var(--bg-white);
    }

    /* Sections */
    article {
      margin-bottom: 4rem;
      position: relative;
    }

    /* Section Numbers */
    .section-label {
      font-family: 'IBM Plex Sans', sans-serif;
      font-size: 0.8125rem;
      font-weight: 600;
      color: var(--primary);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 0.75rem;
      display: block;
    }

    /* Typography */
    h2 {
      font-family: 'IBM Plex Serif', serif;
      font-size: 2rem;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 2rem;
      letter-spacing: -0.01em;
      line-height: 1.3;
    }

    h3 {
      font-family: 'IBM Plex Serif', serif;
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--text-primary);
      margin: 2.5rem 0 1.25rem;
      line-height: 1.4;
    }

    p {
      font-size: 1.0625rem;
      line-height: 1.8;
      color: var(--text-secondary);
      margin-bottom: 1.5rem;
      text-align: justify;
      hyphens: auto;
    }

    p strong {
      color: var(--text-primary);
      font-weight: 600;
    }

    /* Academic Quote Box */
    .theorem-box, .definition-box {
      background: var(--bg-light);
      border-left: 4px solid var(--primary);
      padding: 1.75rem 2rem;
      margin: 2.5rem 0;
      position: relative;
    }

    .theorem-box::before {
      content: 'Nota';
      font-family: 'IBM Plex Sans', sans-serif;
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--primary);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      position: absolute;
      top: -0.75rem;
      left: 1.5rem;
      background: var(--bg-light);
      padding: 0 0.5rem;
    }

    .theorem-box p, .definition-box p {
      margin: 0;
      text-align: left;
      font-size: 1rem;
    }

    /* Figure Container */
    .figure-container {
      margin: 3rem 0;
      text-align: center;
    }

    .figure-wrapper {
      background: var(--bg-white);
      border: 1px solid var(--border);
      padding: 2rem;
      display: inline-block;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }

    .figure-wrapper img {
      max-width: 100%;
      height: auto;
      display: block;
    }

    .figure-caption {
      font-family: 'IBM Plex Sans', sans-serif;
      font-size: 0.9375rem;
      color: var(--text-secondary);
      margin-top: 1rem;
      font-style: italic;
    }

    .figure-caption strong {
      font-weight: 600;
      color: var(--text-primary);
      font-style: normal;
    }

    /* Interactive Demo */
    .demo-section {
      margin: 4rem 0;
      padding: 2rem;
      background: var(--bg-light);
      border: 1px solid var(--border-dark);
    }

    .demo-header {
      margin-bottom: 1.5rem;
    }

    .demo-header h3 {
      margin: 0 0 0.5rem 0;
      font-size: 1.25rem;
    }

    .demo-description {
      font-size: 0.9375rem;
      color: var(--text-muted);
      margin-bottom: 1.5rem;
      text-align: left;
    }

    .demo-container {
      background: #000;
      border: 2px solid var(--border-dark);
      overflow: hidden;
    }

    .demo-container iframe {
      width: 100%;
      height: 600px;
      border: none;
      display: block;
    }

    /* Transformation Cards */
    .transformation-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1.5rem;
      margin: 2.5rem 0;
    }

    .transform-card {
      background: var(--bg-white);
      border: 1px solid var(--border);
      padding: 1.75rem 1.5rem;
      transition: all 0.2s ease;
    }

    .transform-card:hover {
      border-color: var(--primary);
      box-shadow: 0 4px 12px rgba(30, 58, 138, 0.08);
    }

    .transform-card h4 {
      font-family: 'IBM Plex Serif', serif;
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.75rem;
    }

    .transform-card p {
      font-size: 0.9375rem;
      margin: 0;
      text-align: left;
      line-height: 1.6;
    }

    /* Mathematical Expression */
    .math-block {
      margin: 2.5rem 0;
      padding: 2rem;
      background: var(--bg-light);
      border: 1px solid var(--border);
      text-align: center;
      overflow-x: auto;
    }

    /* Divider */
    .section-divider {
      height: 1px;
      background: var(--border);
      margin: 4rem 0;
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .toc-sidebar {
        transform: translateX(-100%);
      }

      .toc-sidebar.open {
        transform: translateX(0);
        box-shadow: 4px 0 12px rgba(0, 0, 0, 0.1);
      }

      .toc-toggle {
        display: block;
      }

      .toc-collapse-btn {
        display: none;
      }

      body.has-toc {
        margin-left: 0;
      }
    }

    @media (max-width: 768px) {
      .institutional-info {
        flex-direction: column;
        text-align: center;
      }

      .course-info {
        text-align: center;
      }

      header {
        padding: 3rem 1.5rem 2rem;
      }

      main {
        padding: 3rem 1.5rem;
      }

      footer {
        padding: 1.5rem 1rem;
      }

      footer .author-info {
        display: block;
        margin: 0.5rem 0;
      }

      h2 {
        font-size: 1.75rem;
      }

      .transformation-grid {
        grid-template-columns: 1fr;
      }

      .demo-container iframe {
        height: 400px;
      }
    }

    /* Print Styles */
    @media print {
      .progress-bar, .demo-container, .toc-sidebar, .toc-toggle {
        display: none;
      }

      body, body.has-toc {
        background: white;
        margin-left: 0;
      }

      main {
        max-width: 100%;
      }
    }

    /* Subtle animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    article {
      animation: fadeIn 0.6s ease-out backwards;
    }

    article:nth-child(1) { animation-delay: 0.1s; }
    article:nth-child(2) { animation-delay: 0.2s; }
    article:nth-child(3) { animation-delay: 0.3s; }
    article:nth-child(4) { animation-delay: 0.4s; }
  </style>
</head>
<body class="has-toc">
  <div class="progress-bar" id="progressBar"></div>

  <!-- Toggle Button for Mobile -->
  <button class="toc-toggle" id="tocToggle" aria-label="Toggle menu">☰</button>

  <!-- Collapse Button for Desktop -->
  <button class="toc-collapse-btn" id="tocCollapseBtn" aria-label="Recolher/Expandir menu" title="Recolher/Expandir menu">◀</button>

  <!-- Table of Contents Sidebar -->
  <aside class="toc-sidebar" id="tocSidebar">
    <div class="toc-header">
      <div class="toc-title">Conteúdo</div>
      <div class="toc-progress">
        <div class="toc-progress-fill" id="tocProgressFill"></div>
      </div>
    </div>
    <nav class="toc-nav">
      <a href="#secao1" class="toc-item" data-section="1">
        <span class="toc-item-number">1</span>
        Introdução
      </a>
      <a href="#secao1-1" class="toc-item toc-subsection" data-section="1.1">
        <span class="toc-item-number">1.1</span>
        O Contexto Prático
      </a>
      <a href="#secao1-2" class="toc-item toc-subsection" data-section="1.2">
        <span class="toc-item-number">1.2</span>
        A Importância do Plano Cartesiano
      </a>
      <a href="#secao2" class="toc-item" data-section="2">
        <span class="toc-item-number">2</span>
        Conceitos Preliminares
      </a>
      <a href="#secao2-1" class="toc-item toc-subsection" data-section="2.1">
        <span class="toc-item-number">2.1</span>
        Geometria
      </a>
      <a href="#secao2-2" class="toc-item toc-subsection" data-section="2.2">
        <span class="toc-item-number">2.2</span>
        Matrizes
      </a>
      <a href="#secao2-3" class="toc-item toc-subsection" data-section="2.3">
        <span class="toc-item-number">2.3</span>
        Transformação Linear
      </a>
      <a href="#secao3" class="toc-item" data-section="3">
        <span class="toc-item-number">3</span>
        Transformações Lineares Planas
      </a>
      <a href="#secao3-1" class="toc-item toc-subsection" data-section="3.1">
        <span class="toc-item-number">3.1</span>
        Reflexão
      </a>
      <a href="#secao3-2" class="toc-item toc-subsection" data-section="3.2">
        <span class="toc-item-number">3.2</span>
        Dilatação e Contração
      </a>
      <a href="#secao3-3" class="toc-item toc-subsection" data-section="3.3">
        <span class="toc-item-number">3.3</span>
        Cisalhamento
      </a>
      <a href="#secao3-4" class="toc-item toc-subsection" data-section="3.4">
        <span class="toc-item-number">3.4</span>
        Rotação
      </a>
      <a href="#secao4" class="toc-item" data-section="4">
        <span class="toc-item-number">4</span>
        Transformações Lineares no Espaço
      </a>
      <a href="#secao4-1" class="toc-item toc-subsection" data-section="4.1">
        <span class="toc-item-number">4.1</span>
        Reflexões em ℝ³
      </a>
      <a href="#secao4-2" class="toc-item toc-subsection" data-section="4.2">
        <span class="toc-item-number">4.2</span>
        Dilatação e Contração 3D
      </a>
      <a href="#secao4-3" class="toc-item toc-subsection" data-section="4.3">
        <span class="toc-item-number">4.3</span>
        Rotações 3D
      </a>
      <a href="#secao4-4" class="toc-item toc-subsection" data-section="4.4">
        <span class="toc-item-number">4.4</span>
        Exemplo: Tetraedro ABCD
      </a>
      <a href="#secao5" class="toc-item" data-section="5">
        <span class="toc-item-number">5</span>
        Transformações Aplicadas aos Polígonos
      </a>
      <a href="#secao5-1" class="toc-item toc-subsection" data-section="5.1">
        <span class="toc-item-number">5.1</span>
        Introdução às Transformações Geométricas
      </a>
      <a href="#secao5-2" class="toc-item toc-subsection" data-section="5.2">
        <span class="toc-item-number">5.2</span>
        Tipos de Transformações Geométricas
      </a>
      <a href="#secao5-3" class="toc-item toc-subsection" data-section="5.3">
        <span class="toc-item-number">5.3</span>
        Transformações com Ponto Fixo
      </a>
      <a href="#secao6" class="toc-item" data-section="6">
        <span class="toc-item-number">6</span>
        Transformações Aplicadas aos Poliedros
      </a>
      <a href="#secao6-1" class="toc-item toc-subsection" data-section="6.1">
        <span class="toc-item-number">6.1</span>
        Translação 3D
      </a>
      <a href="#secao6-2" class="toc-item toc-subsection" data-section="6.2">
        <span class="toc-item-number">6.2</span>
        Escala com Ponto Fixo em 3D
      </a>
      <a href="#secao6-3" class="toc-item toc-subsection" data-section="6.3">
        <span class="toc-item-number">6.3</span>
        Rotação com Ponto Fixo em 3D
      </a>
      <a href="#secao6-4" class="toc-item toc-subsection" data-section="6.4">
        <span class="toc-item-number">6.4</span>
        Centróide de Poliedros
      </a>
      <a href="#secao6-5" class="toc-item toc-subsection" data-section="6.5">
        <span class="toc-item-number">6.5</span>
        Aplicações em Gráficos 3D
      </a>
      <a href="#secao7" class="toc-item" data-section="7">
        <span class="toc-item-number">7</span>
        Animação no Plano usando WebGL
      </a>
      <a href="#secao7-1" class="toc-item toc-subsection" data-section="7.1">
        <span class="toc-item-number">7.1</span>
        Pipeline de Renderização
      </a>
      <a href="#secao7-2" class="toc-item toc-subsection" data-section="7.2">
        <span class="toc-item-number">7.2</span>
        Sistema de Coordenadas WebGL
      </a>
      <a href="#secao7-3" class="toc-item toc-subsection" data-section="7.3">
        <span class="toc-item-number">7.3</span>
        Shaders: Programação na GPU
      </a>
      <a href="#secao7-4" class="toc-item toc-subsection" data-section="7.4">
        <span class="toc-item-number">7.4</span>
        Buffers: Enviando Dados à GPU
      </a>
      <a href="#secao7-5" class="toc-item toc-subsection" data-section="7.5">
        <span class="toc-item-number">7.5</span>
        Uniforms: Parâmetros Globais
      </a>
      <a href="#secao7-6" class="toc-item toc-subsection" data-section="7.6">
        <span class="toc-item-number">7.6</span>
        Loop de Renderização
      </a>
      <a href="#secao7-7" class="toc-item toc-subsection" data-section="7.7">
        <span class="toc-item-number">7.7</span>
        Exemplo Completo
      </a>
      <a href="#secao7-8" class="toc-item toc-subsection" data-section="7.8">
        <span class="toc-item-number">7.8</span>
        Relação com Álgebra Linear
      </a>
      <a href="#secao7-9" class="toc-item toc-subsection" data-section="7.9">
        <span class="toc-item-number">7.9</span>
        Aplicação Prática
      </a>
      <a href="#secao8" class="toc-item" data-section="8">
        <span class="toc-item-number">8</span>
        Animação no espaço
      </a>
      <a href="#secao8-1" class="toc-item toc-subsection" data-section="8.1">
        <span class="toc-item-number">8.1</span>
        Diferenças Fundamentais 2D vs 3D
      </a>
      <a href="#secao8-2" class="toc-item toc-subsection" data-section="8.2">
        <span class="toc-item-number">8.2</span>
        Geometria 3D
      </a>
      <a href="#secao8-3" class="toc-item toc-subsection" data-section="8.3">
        <span class="toc-item-number">8.3</span>
        Vertex Shader 3D: Pipeline MVP
      </a>
      <a href="#secao8-4" class="toc-item toc-subsection" data-section="8.4">
        <span class="toc-item-number">8.4</span>
        Iluminação
      </a>
      <a href="#secao8-5" class="toc-item toc-subsection" data-section="8.5">
        <span class="toc-item-number">8.5</span>
        Comparação: Aplicações 2D vs 3D
      </a>
      <a href="#secao8-6" class="toc-item toc-subsection" data-section="8.6">
        <span class="toc-item-number">8.6</span>
        Relação com Álgebra Linear
      </a>
      <a href="#secao8-7" class="toc-item toc-subsection" data-section="8.7">
        <span class="toc-item-number">8.7</span>
        Animação Coelho
      </a>
      <a href="#secao9" class="toc-item" data-section="9">
        <span class="toc-item-number">9</span>
        Sistema de Animação Interativa
      </a>
      <a href="#secao9-1" class="toc-item toc-subsection" data-section="9.1">
        <span class="toc-item-number">9.1</span>
        Arquitetura do Sistema
      </a>
      <a href="#secao9-2" class="toc-item toc-subsection" data-section="9.2">
        <span class="toc-item-number">9.2</span>
        Gerenciamento de Estado
      </a>
      <a href="#secao9-3" class="toc-item toc-subsection" data-section="9.3">
        <span class="toc-item-number">9.3</span>
        Animação Procedural via Código
      </a>
      <a href="#secao9-4" class="toc-item toc-subsection" data-section="9.4">
        <span class="toc-item-number">9.4</span>
        Aplicação Prática Interativa
      </a>
      <a href="#secao10" class="toc-item" data-section="10">
        <span class="toc-item-number">10</span>
        Conclusão
      </a>
      <a href="#secao10-1" class="toc-item toc-subsection" data-section="10.1">
        <span class="toc-item-number">10.1</span>
        Importância e Aplicações
      </a>
      <a href="#secao10-2" class="toc-item toc-subsection" data-section="10.2">
        <span class="toc-item-number">10.2</span>
        Trabalhos Futuros
      </a>
    </nav>
  </aside>

  <!-- Main Header -->
  <header>
    <div class="header-category">Computação Gráfica • Álgebra Linear</div>
    <h1>WebGL e Transformações Lineares</h1>
    <p class="header-subtitle">
      Um guia prático de álgebra linear aplicada à computação gráfica
    </p>
  </header>

  <!-- Main Content -->
  <main>
    <!-- Introdução -->
    <article id="secao1">
      <span class="section-label">1. Introdução</span>
      <h2>Fundamentos Matemáticos da Computação Gráfica</h2>

      <p>
        A computação gráfica moderna fundamenta-se na aplicação sistemática de conceitos da álgebra linear
        para representação e manipulação de objetos geométricos no espaço bidimensional e tridimensional.
        Esta intersecção entre matemática pura e ciência aplicada possibilita a criação de ambientes virtuais
        complexos, desde jogos eletrônicos até simulações científicas de alta fidelidade.
      </p>

      <h3 id="secao1-1">1.1 O Contexto Prático: Onde Encontramos Computação Gráfica</h3>

      <p>
        A computação gráfica está presente em praticamente todos os aspectos da tecnologia moderna.
        <strong>Engines de jogos</strong> como Unity e Unreal Engine utilizam matrizes de transformação
        para posicionar, rotacionar e dimensionar milhares de objetos simultaneamente em mundos virtuais
        imensos. Até mesmo <strong>interfaces de usuário</strong> modernas, com suas transições suaves 
        e animações fluidas, dependem de transformações geométricas calculadas em tempo real pela GPU.
      </p>

      <p>
        Conforme estabelecido por <strong>Gomes e Velho (2015)</strong>, a computação gráfica pode ser
        compreendida como um conjunto de métodos e técnicas para transformação de dados em imagens através
        de dispositivos gráficos. Neste contexto, a álgebra linear fornece o arcabouço matemático essencial
        para operações de transformação, projeção e renderização.
      </p>

      <h3 id="secao1-2">1.2 A Importância do Plano Cartesiano</h3>

      <p>
        No centro de toda a computação gráfica está um conceito aparentemente simples, mas profundamente
        poderoso: o <strong>sistema de coordenadas cartesianas</strong>. Cada objeto que você vê em uma tela
        — seja um triângulo simples ou um modelo 3D complexo com milhões de polígonos — é definido por
        pontos no espaço, representados por coordenadas numéricas. Um triângulo em 2D, por exemplo, é
        simplesmente três pontos com coordenadas (x, y), armazenados na memória do computador como uma
        sequência de números.
      </p>

      <div class="math-block">
        $$\text{Triângulo ABC} = \begin{bmatrix}
        x_A & y_A \\
        x_B & y_B \\
        x_C & y_C
        \end{bmatrix} = \begin{bmatrix}
        1 & 1 \\
        -1 & 2 \\
        -1 & 0
        \end{bmatrix}$$
      </div>

      <p>
        Estes dados geométricos não ficam estáticos, eles são constantemente manipulados através de
        operações matemáticas. Quando você rotaciona um objeto em um jogo, o computador não está redesenhando
        pixel por pixel; ele está multiplicando as coordenadas de cada vértice por uma <strong>matriz de rotação</strong>.
        Quando você faz zoom, uma <strong>matriz de escala</strong> é aplicada. Quando move a câmera,
        <strong>matrizes de translação</strong> transformam todas as coordenadas do mundo virtual.
        Tudo isso acontece em frações de segundo, permitindo interações fluidas e responsivas.
      </p>

      <div class="theorem-box">
        <p>
          <strong>WebGL (Web Graphics Library)</strong> é uma API JavaScript para renderização de gráficos
          2D e 3D interativos em navegadores web sem uso de plugins. Baseada no OpenGL ES 2.0, permite
          acesso direto à GPU (Graphics Processing Unit) para processamento paralelo de operações matriciais,
          possibilitando renderização em tempo real de cenas complexas com milhões de cálculos por segundo.
          Nesta página, utilizaremos WebGL para demonstrar cada conceito matemático.
        </p>
      </div>
    </article>

    <!-- Conceitos Preliminares -->
    <article id="secao2">
      <span class="section-label">2. Conceitos Preliminares</span>
      <h2>Fundamentos Matemáticos</h2>

      <p>
        A computação gráfica fundamenta-se em conceitos da geometria analítica, álgebra linear e teoria
        de transformações. Esta seção estabelece as bases matemáticas necessárias para compreender como
        objetos geométricos são representados e manipulados computacionalmente.
      </p>

      <h3 id="secao2-1">2.1 Geometria</h3>

      <p>
        O sistema de coordenadas cartesianas, desenvolvido por René Descartes em <em>La Géométrie</em> (1637),
        estabelece correspondência entre geometria e álgebra. Na <strong>geometria sintética</strong>, propriedades
        são estudadas sem coordenadas. Na <strong>geometria analítica</strong>, pontos, retas e figuras são
        expressos numericamente através de coordenadas.
      </p>

      <p>
        No espaço bidimensional <strong>ℝ²</strong>, cada ponto P é determinado por um par ordenado (x, y),
        onde x representa a abscissa e y a ordenada. A origem O = (0, 0) corresponde à interseção dos eixos
        perpendiculares x e y. Os eixos dividem o plano em quatro quadrantes.
      </p>

      <div class="figure-container">
        <div class="figure-wrapper">
          <img src="./assets/images/plano.png" alt="Sistema de Coordenadas Cartesianas ℝ²" width="500">
        </div>
        <p class="figure-caption">
          <strong>Figura 2.1.</strong> Sistema de coordenadas cartesianas em ℝ² com eixos ortogonais.
        </p>
      </div>

      <p>
        No espaço tridimensional <strong>ℝ³</strong>, pontos são representados por triplas ordenadas (x, y, z),
        onde z indica profundidade. Os planos coordenados xOy, xOz e yOz dividem o espaço
        em oito octantes.
      </p>

      <p>
        Na computação gráfica, vértices de polígonos são pontos com coordenadas. Um triângulo com vértices
        A(1,1), B(-1,2) e C(-1,0) é armazenado como array de números: [1, 1, -1, 2, -1, 0]. Para renderização
        no WebGL, estes valores são convertidos em <strong>Float32Array</strong> e enviados à GPU.
      </p>

      <div class="demo-section">
        <div class="demo-header">
          <h3>Demonstração 2.1: Sistema de Coordenadas Cartesianas</h3>
          <p class="demo-description">
            Arraste os pontos para visualizar como coordenadas (x, y) definem posições no plano.
            Observe a relação entre representação numérica e posição geométrica.
          </p>
        </div>
        <div class="demo-container">
          <iframe src="./vetor.html" title="Demo: Plano Cartesiano"></iframe>
        </div>
      </div>

      <h3 id="secao2-2">2.2 Matrizes</h3>

      <p>
        Uma <strong>matriz</strong> é uma tabela retangular de números organizados em linhas e colunas.
        Uma matriz m×n possui m linhas e n colunas. O elemento na linha i e coluna j é denotado por aᵢⱼ.
        Matrizes são fundamentais na computação gráfica pois codificam transformações geométricas.
      </p>

      <p>
        A matriz de vértices de um triângulo ABC é representada como uma matriz 3×2:
      </p>

      <div class="math-block">
        $$\text{Triângulo ABC} = \begin{bmatrix}
        x_A & y_A \\
        x_B & y_B \\
        x_C & y_C
        \end{bmatrix} = \begin{bmatrix}
        1 & 1 \\
        -1 & 2 \\
        -1 & 0
        \end{bmatrix}$$
      </div>

      <p>
        <strong>Operações com matrizes</strong> incluem adição (elemento a elemento), multiplicação por escalar
        (multiplicar todos os elementos) e multiplicação matricial. A multiplicação de matrizes A (m×n) e B (n×p)
        resulta em C (m×p), onde cada elemento cᵢⱼ = Σₖ aᵢₖ·bₖⱼ. Esta operação <strong>não é comutativa</strong>:
        AB ≠ BA em geral.
      </p>

      <div class="math-block">
        $$\text{Multiplicação: } \begin{bmatrix} a & b \\ c & d \end{bmatrix}
        \begin{bmatrix} x \\ y \end{bmatrix} =
        \begin{bmatrix} ax + by \\ cx + dy \end{bmatrix}$$
      </div>

      <p>
        A <strong>matriz identidade</strong> I possui 1 na diagonal principal e 0 nos demais elementos.
        Multiplicar qualquer matriz por I resulta na própria matriz: AI = IA = A. Matrizes de transformação
        2×2 são usadas para transformações lineares em ℝ², enquanto matrizes 3×3 representam transformações
        em ℝ² usando coordenadas homogêneas.
      </p>

      <div class="theorem-box">
        <p>
          <strong>Eficiência Computacional:</strong> A GPU processa multiplicações matriciais em paralelo,
          aplicando a mesma transformação a milhares de vértices simultaneamente. Esta paralelização é
          o que permite renderização em tempo real de cenas complexas a 60 frames por segundo.
        </p>
      </div>

      <div class="demo-section">
        <div class="demo-header">
          <h3>Demonstração 2.2: Transformações Matriciais</h3>
          <p class="demo-description">
            Insira valores em uma matriz 2×2 e observe em tempo real a transformação aplicada a um triângulo.
            Experimente os presets ou crie suas próprias transformações.
          </p>
        </div>
        <div class="demo-container">
          <iframe src="./matriz.html" title="Demo: Transformações Matriciais"></iframe>
        </div>
      </div>

      <h3 id="secao2-3">2.3 Transformação Linear</h3>

      <p>
        Um <strong>espaço vetorial</strong> V é um conjunto com operações de adição e multiplicação por escalar
        que satisfazem axiomas de fechamento, associatividade, comutatividade, existência de elemento neutro
        e inverso.
      </p>

      <p>
        Um <strong>vetor</strong> é um elemento de um espaço vetorial. Geometricamente, possui magnitude e direção.
        Em ℝ², vetores são representados como (x, y) ou como vetores coluna. Operações vetoriais incluem:
      </p>

      <div class="math-block">
        $$\begin{aligned}
        \text{Adição: } & \mathbf{u} + \mathbf{v} = (u_x + v_x,\, u_y + v_y) \\
        \text{Mult. escalar: } & \alpha\mathbf{u} = (\alpha u_x,\, \alpha u_y) \\
        \text{Produto escalar: } & \mathbf{u} \cdot \mathbf{v} = u_x v_x + u_y v_y \\
        \text{Norma: } & |\mathbf{u}| = \sqrt{u_x^2 + u_y^2}
        \end{aligned}$$
      </div>

      <p>
        Uma <strong>combinação linear</strong> de vetores v₁, v₂, ..., vₙ é expressa como α₁v₁ + α₂v₂ + ... + αₙvₙ,
        onde αᵢ são escalares. Vetores são <strong>linearmente independentes</strong> se nenhum pode ser expresso
        como combinação linear dos outros. Uma <strong>base</strong> de um espaço vetorial é um conjunto linearmente
        independente que gera todo o espaço. A <strong>dimensão</strong> é o número de vetores em uma base.
      </p>

      <p>
        Uma <strong>transformação linear</strong> T: V → W preserva operações vetoriais:
      </p>

      <div class="math-block">
        $$\begin{aligned}
        T(\mathbf{u} + \mathbf{v}) &= T(\mathbf{u}) + T(\mathbf{v}) \\
        T(\alpha\mathbf{v}) &= \alpha T(\mathbf{v})
        \end{aligned}$$
      </div>

      <p>
        Propriedades fundamentais: T(0) = 0 (a origem é sempre mapeada para a origem) e transformações preservam
        retas (retas permanecem retas após transformação). A <strong>imagem</strong> Im(T) é o conjunto de todos
        os vetores que podem ser obtidos aplicando T.
      </p>

      <p>
        Toda transformação linear T: ℝⁿ → ℝᵐ pode ser representada por uma <strong>matriz m×n</strong>, onde
        as colunas da matriz são as imagens dos vetores da base. Aplicar a transformação é equivalente a
        multiplicar a matriz pelo vetor: T(v) = Av. Esta representação matricial permite aplicação eficiente
        de transformações a múltiplos vértices simultaneamente.
      </p>

      <div class="theorem-box">
        <p>
          <strong>Aplicação em CG:</strong> Cada vértice de um polígono é um vetor posição. Transformações
          geométricas (rotação, escala, reflexão) são transformações lineares representadas por matrizes.
          Vetores normais (perpendiculares a superfícies) são essenciais para cálculos de iluminação.
        </p>
      </div>
    </article>

    <div class="section-divider"></div>

    <!-- Transformações Lineares Planas -->
    <article id="secao3">
      <span class="section-label">3. Transformações Lineares Planas (ℝ²)</span>
      <h2>Operações Geométricas no Plano</h2>

      <p>
        Uma transformação linear T: ℝ² → ℝ² preserva operações de adição vetorial e multiplicação
        por escalar. Estas transformações são fundamentais na computação gráfica, pois permitem
        manipular formas geométricas de maneira sistemática através de operações matriciais.
      </p>

      <p>
        Toda transformação linear pode ser representada por uma matriz 2×2, permitindo aplicação
        eficiente a múltiplos vértices simultaneamente. Propriedades importantes: transformações
        lineares sempre mapeiam a origem para a origem T(0,0) = (0,0), preservam retas e preservam paralelismo.
      </p>

      <h3 id="secao3-1">3.1 Reflexão</h3>

      <p>
        Reflexão espelha pontos em relação a um eixo, invertendo uma coordenada. A matriz de reflexão
        possui determinante -1, indicando inversão de orientação.
      </p>

      <div class="math-block">
        $$\text{Reflexão no eixo } x: \quad R_x = \begin{bmatrix} 1 & 0 \\ 0 & -1 \end{bmatrix}$$
        <br><br>
        $$\text{Reflexão no eixo } y: \quad R_y = \begin{bmatrix} -1 & 0 \\ 0 & 1 \end{bmatrix}$$
        <br><br>
        $$\text{Reflexão na origem: } \quad R_O = \begin{bmatrix} -1 & 0 \\ 0 & -1 \end{bmatrix}$$
      </div>

      <p>
        Aplicando reflexão no eixo x ao ponto (2, 3): R<sub>x</sub>(2, 3) = (2, -3).
      </p>

      <h3 id="secao3-2">3.2 Dilatação e Contração (Escala)</h3>

      <p>
        Escala altera dimensões de objetos por fatores multiplicativos. Quando α = β, a escala é
        <strong>uniforme</strong> (mantém proporções). Quando α ≠ β, a escala é <strong>não-uniforme</strong>.
      </p>

      <div class="math-block">
        $$S(\alpha, \beta) = \begin{bmatrix} \alpha & 0 \\ 0 & \beta \end{bmatrix}$$
      </div>

      <p>
        Se α > 1 ou β > 1, ocorre <strong>dilatação</strong> (aumento). Se 0 < α < 1 ou 0 < β < 1,
        ocorre <strong>contração</strong> (redução). Exemplo: S(2, 0.5) aplica ampliação horizontal
        de 2x e redução vertical pela metade.
      </p>

      <h4>Demonstração: Escala a partir da Origem vs. Centróide</h4>

      <p>
        Um aspecto importante da escala é o <strong>ponto fixo</strong> da transformação.
        A transformação linear de escala S(α, β) sempre mantém a origem (0,0) fixa.
        Porém, na prática, frequentemente desejamos escalar objetos mantendo seu centro
        geométrico fixo. A demonstração abaixo ilustra essa diferença fundamental:
      </p>

      <div class="demo-box">
        <div class="iframe-container">
          <iframe
            src="./escala_comparacao/index.html"
            width="100%"
            height="450px"
            frameborder="0"
            title="Comparação de Escala: Origem vs Centróide"
            style="border: 1px solid #ddd; border-radius: 4px;">
          </iframe>
        </div>

        <p class="demo-note">
          <strong>Observação importante:</strong> À esquerda, a escala linear pura S(α, α)
          desloca o triângulo conforme ele cresce/diminui, pois apenas a origem permanece fixa.
          À direita, a escala com centróide fixo combina translações com a escala linear,
          resultando em uma transformação afim que preserva a posição visual do objeto.
        </p>
      </div>

      <h3 id="secao3-3">3.3 Cisalhamento</h3>

      <p>
        Cisalhamento desloca coordenadas proporcionalmente a outra coordenada, distorcendo a forma
        sem alterar área. Converte retângulos em paralelogramos.
      </p>

      <div class="math-block">
        $$\text{Cisalhamento em } x: \quad Sh_x(k) = \begin{bmatrix} 1 & k \\ 0 & 1 \end{bmatrix}$$
        <br><br>
        $$\text{Cisalhamento em } y: \quad Sh_y(k) = \begin{bmatrix} 1 & 0 \\ k & 1 \end{bmatrix}$$
      </div>

      <p>
        Para Sh<sub>x</sub>(k), um ponto (x, y) é mapeado para (x + ky, y). Quanto maior k, maior a distorção.
        Aplicação comum: criar efeitos de perspectiva e inclinação em fontes tipográficas.
      </p>

      <div class="figure-container">
        <div class="figure-wrapper">
          <img src="./assets/images/cisX.png" alt="Cisalhamento no eixo x" width="500">
        </div>
        <p class="figure-caption">
          <strong>Figura 3.1.</strong> Cisalhamento no eixo x.
        </p>
      </div>

      <h3 id="secao3-4">3.4 Rotação</h3>

      <p>
        Rotação gira vetores por um ângulo θ (em radianos) no sentido <strong>anti-horário</strong>
        em torno da origem. É uma transformação que preserva distâncias e ângulos (isometria).
      </p>

      <div class="math-block">
        $$R(\theta) = \begin{bmatrix} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta \end{bmatrix}$$
      </div>

      <p>
        Rotações comuns em graus:
      </p>

      <div class="math-block">
        $$R(90°) = \begin{bmatrix} 0 & -1 \\ 1 & 0 \end{bmatrix}, \quad
        R(180°) = \begin{bmatrix} -1 & 0 \\ 0 & -1 \end{bmatrix}, \quad
        R(270°) = \begin{bmatrix} 0 & 1 \\ -1 & 0 \end{bmatrix}$$
      </div>

      <h4>Demonstração: Rotação a partir da Origem vs. Centróide</h4>

      <p>
        Assim como na escala, o <strong>ponto fixo</strong> da rotação é crucial.
        A transformação linear de rotação R(θ) sempre mantém a origem (0,0) fixa.
        Para rotacionar objetos em torno de seu próprio centro, é necessário combinar
        translações com a rotação. A demonstração abaixo ilustra essa diferença:
      </p>

      <div class="demo-box">
        <div class="iframe-container">
          <iframe
            src="./rotacao_comparacao/index.html"
            width="100%"
            height="450px"
            frameborder="0"
            title="Comparação de Rotação: Origem vs Centróide"
            style="border: 1px solid #ddd; border-radius: 4px;">
          </iframe>
        </div>

        <p class="demo-note">
          <strong>Observação importante:</strong> À esquerda, a rotação linear pura R(θ)
          faz o triângulo orbitar em torno da origem, mudando sua posição no plano.
          À direita, a rotação com centróide fixo mantém o triângulo girando "no lugar",
          em torno de seu próprio centro geométrico. Esta é a rotação esperada.
        </p>
      </div>

      <div class="theorem-box">
        <p>
          <strong>Composição de Transformações:</strong> Múltiplas transformações lineares podem
          ser combinadas multiplicando suas matrizes. Para aplicar transformação T₁ seguida de T₂,
          calcula-se M = T₂ · T₁ (ordem reversa). A ordem importa: T₁ · T₂ ≠ T₂ · T₁ em geral.
          Exemplo: rotacionar 45° e depois escalar 2x resulta em matriz M = S(2,2) · R(45°).
        </p>
      </div>
    </article>

    <div class="section-divider"></div>

    <!-- Transformações Lineares no Espaço -->
    <article id="secao4">
      <span class="section-label">4. Transformações Lineares no Espaço (ℝ³)</span>
      <h2>Operações Geométricas no Espaço Tridimensional</h2>

      <p>
        Transformações lineares em ℝ³ estendem os conceitos do plano para o espaço tridimensional.
        Uma transformação linear T: ℝ³ → ℝ³ é representada por uma matriz 3×3, aplicando as mesmas
        operações de reflexão, escala e rotação a poliedros (sólidos 3D).
      </p>

      <h3 id="secao4-1">4.1 Reflexões em ℝ³</h3>

      <p>
        Reflexão em 3D espelha pontos em relação a um plano coordenado, invertendo uma das coordenadas:
      </p>

      <div class="math-block">
        $$\text{Reflexão no plano } xOy: \quad R_{xOy} = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & -1 \end{bmatrix}$$
        <br><br>
        $$\text{Reflexão no plano } xOz: \quad R_{xOz} = \begin{bmatrix} 1 & 0 & 0 \\ 0 & -1 & 0 \\ 0 & 0 & 1 \end{bmatrix}$$
        <br><br>
        $$\text{Reflexão no plano } yOz: \quad R_{yOz} = \begin{bmatrix} -1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}$$
      </div>

      <p>
        Aplicação: espelhar modelo 3D, criar simetrias em objetos tridimensionais.
      </p>

      <h3 id="secao4-2">4.2 Dilatação e Contração 3D</h3>

      <p>
        Escala tridimensional altera dimensões independentemente em cada eixo:
      </p>

      <div class="math-block">
        $$\text{Escala uniforme: } \quad S(\alpha) = \begin{bmatrix} \alpha & 0 & 0 \\ 0 & \alpha & 0 \\ 0 & 0 & \alpha \end{bmatrix}$$
        <br><br>
        $$\text{Escala não-uniforme: } \quad S(\alpha_x, \alpha_y, \alpha_z) = \begin{bmatrix} \alpha_x & 0 & 0 \\ 0 & \alpha_y & 0 \\ 0 & 0 & \alpha_z \end{bmatrix}$$
      </div>

      <p>
        Exemplo: S(2, 1, 0.5) duplica dimensão em x, mantém y, e reduz z pela metade.
      </p>

      <h3 id="secao4-3">4.3 Rotações 3D</h3>

      <p>
        Em 3D, rotações ocorrem em torno de um dos três eixos coordenados. O ângulo θ é medido em radianos,
        sentido anti-horário quando olhando do eixo positivo em direção à origem:
      </p>

      <div class="math-block">
        $$\text{Rotação em torno do eixo } x: \quad R_x(\theta) = \begin{bmatrix} 1 & 0 & 0 \\ 0 & \cos\theta & -\sin\theta \\ 0 & \sin\theta & \cos\theta \end{bmatrix}$$
      </div>

      <div class="math-block">
        $$\text{Rotação em torno do eixo } y: \quad R_y(\theta) = \begin{bmatrix} \cos\theta & 0 & \sin\theta \\ 0 & 1 & 0 \\ -\sin\theta & 0 & \cos\theta \end{bmatrix}$$
      </div>

      <div class="math-block">
        $$\text{Rotação em torno do eixo } z: \quad R_z(\theta) = \begin{bmatrix} \cos\theta & -\sin\theta & 0 \\ \sin\theta & \cos\theta & 0 \\ 0 & 0 & 1 \end{bmatrix}$$
      </div>

      <h3 id="secao4-4">4.4 Exemplo: Tetraedro ABCD</h3>

      <p>
        Considere um tetraedro com vértices A(1,0,0), B(0,1,0), C(0,0,1) e D(0,0,0).
        Aplicando rotação de 90° no eixo y:
      </p>

      <div class="math-block">
        $$R_y(90°) = \begin{bmatrix} 0 & 0 & 1 \\ 0 & 1 & 0 \\ -1 & 0 & 0 \end{bmatrix}$$
      </div>

      <p>
        O vértice A(1,0,0) é transformado para A'(0,0,-1). Os demais vértices são calculados similarmente.
      </p>

      <div class="theorem-box">
        <p>
          <strong>Aplicações em Gráficos 3D:</strong> Rotações 3D são essenciais para controles de câmera
          (pitch, yaw, roll), orientação de objetos, e animações. Engines gráficas como Unity e Unreal
          utilizam quaternions além de matrizes para evitar gimbal lock e interpolar rotações suavemente.
        </p>
      </div>

    </article>

    <div class="section-divider"></div>

    <!-- Transformações Aplicadas aos Polígonos -->
    <article id="secao5">
      <span class="section-label">5. Transformações Aplicadas aos Polígonos (ℝ²)</span>
      <h2>Transformações Geométricas e Composição</h2>

      <p>
        As transformações lineares estudadas na Seção 3 preservam sempre a origem: T(0,0) = (0,0).
        Contudo, na prática da computação gráfica, necessita-se posicionar objetos livremente no plano,
        rotacioná-los em torno de pontos arbitrários e compor múltiplas operações. Estas capacidades
        são fornecidas pelas transformações geométricas, que incluem translações
        e permitem especificação de pontos fixos.
      </p>

      <h3 id="secao5-1">5.1 Introdução às Transformações Geométricas</h3>

      <p>
        Uma transformação afim é da forma T(v) = Av + b, onde A é uma matriz e b um vetor de translação.
        Diferentemente de transformações lineares, transformações afins <strong>não preservam a origem</strong>,
        permitindo deslocamentos.
      </p>

      <h3 id="secao5-2">5.2 Tipos de Transformações Geométricas em ℝ²</h3>

      <h4>5.2.1 Translação</h4>

      <p>
        Translação desloca todos os vértices de um polígono por um vetor (α, β). A operação é definida por:
      </p>

      <div class="math-block">
        $$(x', y') = (x + \alpha, y + \beta)$$
      </div>

      <p>
        Esta operação <strong>não é linear</strong>, pois T(0,0) = (α, β) ≠ (0,0).
      </p>

      <p>
        <strong>Exemplo 5.1:</strong> Considere um triângulo ABC com vértices A(1, 1), B(3, 1) e C(2, 3).
        Aplicando uma translação T(2, -1), obtemos:
      </p>

      <div class="math-block">
        $$\begin{aligned}
        A'(x', y') &= (1 + 2,\, 1 + (-1)) = (3, 0) \\
        B'(x', y') &= (3 + 2,\, 1 + (-1)) = (5, 0) \\
        C'(x', y') &= (2 + 2,\, 3 + (-1)) = (4, 2)
        \end{aligned}$$
      </div>

      <p>
        O triângulo foi deslocado 2 unidades para a direita e 1 unidade para baixo. A forma e
        orientação do triângulo permanecem inalteradas, apenas sua posição no plano muda.
      </p>

      <p>
        <strong>Aplicações:</strong> Posicionamento de objetos em cenas, animações de movimento,
        deslocamento de câmera.
      </p>

      <h4>5.2.2 Escala (Ampliação/Redução)</h4>

      <p>
        Escala altera as dimensões de um polígono por fatores s<sub>x</sub> e s<sub>y</sub>. Quando
        s<sub>x</sub> = s<sub>y</sub>, a escala é <strong>uniforme</strong> e mantém proporções. Quando
        s<sub>x</sub> ≠ s<sub>y</sub>, a escala é <strong>não-uniforme</strong>, distorcendo o objeto.
      </p>

      <div class="math-block">
        $$S(s_x, s_y) = \begin{bmatrix} s_x & 0 \\ 0 & s_y \end{bmatrix}$$
      </div>

      <p>
        Valores s<sub>x</sub> > 1 ou s<sub>y</sub> > 1 causam ampliação. Valores 0 < s < 1 causam redução.
      </p>

      <p>
        <strong>Exemplo 5.2:</strong> Aplicando escala S(2, 0.5) ao quadrado com vértices
        A(1, 1), B(3, 1), C(3, 3) e D(1, 3):
      </p>

      <div class="math-block">
        $$\begin{aligned}
        A' &= \begin{bmatrix} 2 & 0 \\ 0 & 0.5 \end{bmatrix} \begin{bmatrix} 1 \\ 1 \end{bmatrix}
        = \begin{bmatrix} 2 \cdot 1 \\ 0.5 \cdot 1 \end{bmatrix} = \begin{bmatrix} 2 \\ 0.5 \end{bmatrix} \\
        B' &= \begin{bmatrix} 2 & 0 \\ 0 & 0.5 \end{bmatrix} \begin{bmatrix} 3 \\ 1 \end{bmatrix}
        = \begin{bmatrix} 6 \\ 0.5 \end{bmatrix} \\
        C' &= \begin{bmatrix} 2 & 0 \\ 0 & 0.5 \end{bmatrix} \begin{bmatrix} 3 \\ 3 \end{bmatrix}
        = \begin{bmatrix} 6 \\ 1.5 \end{bmatrix} \\
        D' &= \begin{bmatrix} 2 & 0 \\ 0 & 0.5 \end{bmatrix} \begin{bmatrix} 1 \\ 3 \end{bmatrix}
        = \begin{bmatrix} 2 \\ 1.5 \end{bmatrix}
        \end{aligned}$$
      </div>

      <p>
        O quadrado original foi transformado em um retângulo com o dobro da largura (ampliado em x)
        e metade da altura (reduzido em y). Esta é uma escala não-uniforme.
      </p>

      <h4>5.2.3 Rotação</h4>

      <p>
        Rotação gira um polígono por ângulo θ (radianos) em torno da origem, no sentido anti-horário.
        A matriz de rotação é:
      </p>

      <div class="math-block">
        $$R(\theta) = \begin{bmatrix} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta \end{bmatrix}$$
      </div>

      <p>
        Para ângulos comuns: R(45°) ≈ [0.707, -0.707; 0.707, 0.707], R(90°) = [0, -1; 1, 0].
      </p>

      <p>
        <strong>Exemplo 5.3:</strong> Rotacionando o ponto P(2, 0) por 90° (π/2 radianos) em torno da origem:
      </p>

      <div class="math-block">
        $$\begin{aligned}
        R(90°) &= \begin{bmatrix} \cos(90°) & -\sin(90°) \\ \sin(90°) & \cos(90°) \end{bmatrix}
        = \begin{bmatrix} 0 & -1 \\ 1 & 0 \end{bmatrix} \\
        P' &= \begin{bmatrix} 0 & -1 \\ 1 & 0 \end{bmatrix} \begin{bmatrix} 2 \\ 0 \end{bmatrix}
        = \begin{bmatrix} 0 \cdot 2 + (-1) \cdot 0 \\ 1 \cdot 2 + 0 \cdot 0 \end{bmatrix}
        = \begin{bmatrix} 0 \\ 2 \end{bmatrix}
        \end{aligned}$$
      </div>

      <p>
        O ponto P(2, 0), localizado no eixo x positivo, foi rotacionado 90° para a posição P'(0, 2)
        no eixo y positivo, como esperado para uma rotação anti-horária.
      </p>

      <h3 id="secao5-3">5.3 Transformações com Ponto Fixo</h3>

      <p>
        Frequentemente necessita-se aplicar rotação ou escala mantendo um ponto específico P fixo,
        ao invés de transformar em torno da origem. Isto é essencial para manipulação intuitiva
        de objetos gráficos.
      </p>

      <h4>5.3.1 Escala com Ponto Fixo</h4>

      <p>
        Para escalar um polígono mantendo ponto P(p<sub>x</sub>, p<sub>y</sub>) fixo, utiliza-se
        o seguinte algoritmo:
      </p>

      <div class="math-block">
        $$\begin{aligned}
        &\text{1. Transladar P para a origem:} \quad T(-p_x, -p_y) \\
        &\text{2. Aplicar escala:} \quad S(s_x, s_y) \\
        &\text{3. Transladar de volta:} \quad T(p_x, p_y)
        \end{aligned}$$
      </div>

      <p>
        A matriz composta é M = T(p<sub>x</sub>, p<sub>y</sub>) · S(s<sub>x</sub>, s<sub>y</sub>) · T(-p<sub>x</sub>, -p<sub>y</sub>).
        Esta composição garante que o ponto P permanece inalterado após a transformação.
      </p>

      <p>
        <strong>Exemplo 5.4:</strong> Escalar o triângulo com vértices A(1, 1), B(3, 1) e C(2, 3)
        por fator uniforme 2 mantendo o ponto A(1, 1) fixo.
      </p>

      <p>
        <strong>Passo 1:</strong> Transladar A para a origem: T(-1, -1)
      </p>

      <div class="math-block">
        $$\begin{aligned}
        A_1 &= (1 - 1,\, 1 - 1) = (0, 0) \\
        B_1 &= (3 - 1,\, 1 - 1) = (2, 0) \\
        C_1 &= (2 - 1,\, 3 - 1) = (1, 2)
        \end{aligned}$$
      </div>

      <p>
        <strong>Passo 2:</strong> Aplicar escala S(2, 2):
      </p>

      <div class="math-block">
        $$\begin{aligned}
        A_2 &= (0 \cdot 2,\, 0 \cdot 2) = (0, 0) \\
        B_2 &= (2 \cdot 2,\, 0 \cdot 2) = (4, 0) \\
        C_2 &= (1 \cdot 2,\, 2 \cdot 2) = (2, 4)
        \end{aligned}$$
      </div>

      <p>
        <strong>Passo 3:</strong> Transladar de volta: T(1, 1)
      </p>

      <div class="math-block">
        $$\begin{aligned}
        A' &= (0 + 1,\, 0 + 1) = (1, 1) \\
        B' &= (4 + 1,\, 0 + 1) = (5, 1) \\
        C' &= (2 + 1,\, 4 + 1) = (3, 5)
        \end{aligned}$$
      </div>

      <p>
        O vértice A permaneceu em (1, 1) como ponto fixo, enquanto os vértices B e C tiveram
        suas distâncias relativas a A duplicadas.
      </p>

      <h4>5.3.2 Rotação com Ponto Fixo</h4>

      <p>
        Para rotacionar um polígono θ radianos em torno de ponto P (não a origem), aplica-se o mesmo
        princípio de translação-transformação-translação:
      </p>

      <div class="math-block">
        $$\begin{aligned}
        &\text{1. Transladar P à origem:} \quad T(-p_x, -p_y) \\
        &\text{2. Aplicar rotação:} \quad R(\theta) \\
        &\text{3. Transladar de volta:} \quad T(p_x, p_y)
        \end{aligned}$$
      </div>

      <p>
        <strong>Exemplo 5.5:</strong> Rotacionar o triângulo com vértices A(1, 1), B(3, 1) e C(2, 3)
        por 90° em torno do ponto fixo A(1, 1).
      </p>

      <p>
        <strong>Passo 1:</strong> Transladar A para a origem: T(-1, -1)
      </p>

      <div class="math-block">
        $$\begin{aligned}
        A_1 &= (1 - 1,\, 1 - 1) = (0, 0) \\
        B_1 &= (3 - 1,\, 1 - 1) = (2, 0) \\
        C_1 &= (2 - 1,\, 3 - 1) = (1, 2)
        \end{aligned}$$
      </div>

      <p>
        <strong>Passo 2:</strong> Aplicar rotação R(90°):
      </p>

      <div class="math-block">
        $$\begin{aligned}
        A_2 &= \begin{bmatrix} 0 & -1 \\ 1 & 0 \end{bmatrix} \begin{bmatrix} 0 \\ 0 \end{bmatrix}
        = \begin{bmatrix} 0 \\ 0 \end{bmatrix} \\
        B_2 &= \begin{bmatrix} 0 & -1 \\ 1 & 0 \end{bmatrix} \begin{bmatrix} 2 \\ 0 \end{bmatrix}
        = \begin{bmatrix} 0 \\ 2 \end{bmatrix} \\
        C_2 &= \begin{bmatrix} 0 & -1 \\ 1 & 0 \end{bmatrix} \begin{bmatrix} 1 \\ 2 \end{bmatrix}
        = \begin{bmatrix} -2 \\ 1 \end{bmatrix}
        \end{aligned}$$
      </div>

      <p>
        <strong>Passo 3:</strong> Transladar de volta: T(1, 1)
      </p>

      <div class="math-block">
        $$\begin{aligned}
        A' &= (0 + 1,\, 0 + 1) = (1, 1) \\
        B' &= (0 + 1,\, 2 + 1) = (1, 3) \\
        C' &= (-2 + 1,\, 1 + 1) = (-1, 2)
        \end{aligned}$$
      </div>

      <p>
        O triângulo foi rotacionado 90° em torno do vértice A. O vértice A permaneceu fixo
        em (1, 1), enquanto B foi movido de (3, 1) para (1, 3) e C foi movido de (2, 3) para
        (-1, 2), ambos descrevendo arcos de 90° em torno de A.
      </p>

      <h4>5.3.3 Caso Especial: Centróide</h4>

      <p>
        Em muitas aplicações, deseja-se rotacionar ou escalar em torno do <strong>centróide</strong>
        (centro geométrico) do polígono. O centróide de n vértices é calculado como:
      </p>

      <div class="math-block">
        $$\bar{x} = \frac{1}{n}\sum_{i=1}^{n} x_i, \quad \bar{y} = \frac{1}{n}\sum_{i=1}^{n} y_i$$
      </div>

      <p>
        Transformações em torno do centróide produzem resultados visualmente naturais, pois o objeto
        gira ou escala em torno do seu próprio centro.
      </p>

      <p>
        <strong>Exemplo 5.6:</strong> Calcular o centróide do triângulo com vértices A(1, 1), B(5, 1) e C(3, 5):
      </p>

      <div class="math-block">
        $$\begin{aligned}
        \bar{x} &= \frac{1 + 5 + 3}{3} = \frac{9}{3} = 3 \\
        \bar{y} &= \frac{1 + 1 + 5}{3} = \frac{7}{3} \approx 2.33
        \end{aligned}$$
      </div>

      <p>
        O centróide está localizado em G(3, 2.33). Para rotacionar este triângulo em torno de seu
        centro, utilizaríamos P = G nas transformações com ponto fixo.
      </p>

      <div class="theorem-box">
        <p>
          <strong>Implementação em WebGL:</strong> O código existente em <code>animation2d/index.js</code>
          implementa transformações com ponto fixo através da variável <code>isCentering</code> (linha 7)
          e da função <code>toggleCentering()</code> (linha 9-11). O vertex shader (linhas 157-190)
          aplica o algoritmo de translação-transformação-translação usando o uniform <code>u_center</code>
          quando <code>isCenter</code> é verdadeiro.
        </p>
      </div>
    </article>

    <div class="section-divider"></div>

    <!-- Transformações Aplicadas aos Poliedros -->
    <article id="secao6">
      <span class="section-label">6. Transformações Aplicadas aos Poliedros (ℝ³)</span>
      <h2>Transformações Geométricas no Espaço Tridimensional</h2>

      <p>
        As transformações geométricas estendem-se ao espaço tridimensional, permitindo manipulação
        de poliedros através de translações, rotações e escalas com pontos fixos arbitrários. Assim como
        em ℝ², utiliza-se <strong>coordenadas homogêneas</strong> para representar transformações afins
        como multiplicação matricial, empregando matrizes 4×4.
      </p>

      <h3 id="secao6-1">6.1 Translação em 3D</h3>

      <p>
        Translação desloca todos os vértices de um poliedro por um vetor (α, β, γ):
      </p>

      <div class="math-block">
        $$(x', y', z') = (x + \alpha,\, y + \beta,\, z + \gamma)$$
      </div>

      <p>
        <strong>Exemplo 6.1:</strong> Transladar o tetraedro com vértices A(1, 0, 0), B(0, 1, 0),
        C(0, 0, 1) e D(0, 0, 0) por vetor (2, -1, 3):
      </p>

      <div class="math-block">
        $$\begin{aligned}
        A' &= (1 + 2,\, 0 + (-1),\, 0 + 3) = (3, -1, 3) \\
        B' &= (0 + 2,\, 1 + (-1),\, 0 + 3) = (2, 0, 3) \\
        C' &= (0 + 2,\, 0 + (-1),\, 1 + 3) = (2, -1, 4) \\
        D' &= (0 + 2,\, 0 + (-1),\, 0 + 3) = (2, -1, 3)
        \end{aligned}$$
      </div>

      <!-- TODO: ADICIONAR IMAGEM - Tetraedro sendo transladado no espaço 3D com vetor destacado -->

      <h3 id="secao6-2">6.2 Escala com Ponto Fixo em 3D</h3>

      <p>
        Para escalar um poliedro mantendo ponto P(p<sub>x</sub>, p<sub>y</sub>, p<sub>z</sub>) fixo,
        aplica-se o algoritmo:
      </p>

      <div class="math-block">
        $$\begin{aligned}
        &\text{1. Transladar P para a origem:} \quad T(-p_x, -p_y, -p_z) \\
        &\text{2. Aplicar escala:} \quad S(s_x, s_y, s_z) \\
        &\text{3. Transladar de volta:} \quad T(p_x, p_y, p_z)
        \end{aligned}$$
      </div>

      <p>
        A matriz de escala 3D (não-uniforme) é:
      </p>

      <div class="math-block">
        $$S(s_x, s_y, s_z) = \begin{bmatrix}
        s_x & 0 & 0 \\
        0 & s_y & 0 \\
        0 & 0 & s_z
        \end{bmatrix}$$
      </div>

      <h3 id="secao6-3">6.3 Rotação com Ponto Fixo em 3D</h3>

      <p>
        Para rotacionar um poliedro θ radianos em torno de um eixo, mantendo ponto P fixo:
      </p>

      <div class="math-block">
        $$\begin{aligned}
        &\text{1. Transladar P à origem:} \quad T(-p_x, -p_y, -p_z) \\
        &\text{2. Aplicar rotação no eixo desejado:} \quad R_{\text{eixo}}(\theta) \\
        &\text{3. Transladar de volta:} \quad T(p_x, p_y, p_z)
        \end{aligned}$$
      </div>

      <p>
        As matrizes de rotação em 3D em torno dos eixos coordenados são:
      </p>

      <div class="math-block">
        $$R_x(\theta) = \begin{bmatrix}
        1 & 0 & 0 \\
        0 & \cos\theta & -\sin\theta \\
        0 & \sin\theta & \cos\theta
        \end{bmatrix}$$
      </div>

      <div class="math-block">
        $$R_y(\theta) = \begin{bmatrix}
        \cos\theta & 0 & \sin\theta \\
        0 & 1 & 0 \\
        -\sin\theta & 0 & \cos\theta
        \end{bmatrix}$$
      </div>

      <div class="math-block">
        $$R_z(\theta) = \begin{bmatrix}
        \cos\theta & -\sin\theta & 0 \\
        \sin\theta & \cos\theta & 0 \\
        0 & 0 & 1
        \end{bmatrix}$$
      </div>

      <p>
        <strong>Exemplo 6.2:</strong> Rotacionar o tetraedro com vértices A(2, 0, 0), B(1, 1, 0),
        C(1, 0, 1) e D(1, 0, 0) por 90° em torno do eixo Y, mantendo D(1, 0, 0) fixo.
      </p>

      <p>
        <strong>Passo 1:</strong> Transladar D para origem: T(-1, 0, 0)
      </p>

      <div class="math-block">
        $$\begin{aligned}
        A_1 &= (2 - 1,\, 0,\, 0) = (1, 0, 0) \\
        B_1 &= (1 - 1,\, 1,\, 0) = (0, 1, 0) \\
        C_1 &= (1 - 1,\, 0,\, 1) = (0, 0, 1) \\
        D_1 &= (1 - 1,\, 0,\, 0) = (0, 0, 0)
        \end{aligned}$$
      </div>

      <p>
        <strong>Passo 2:</strong> Aplicar rotação R<sub>y</sub>(90°):
      </p>

      <div class="math-block">
        $$R_y(90°) = \begin{bmatrix} 0 & 0 & 1 \\ 0 & 1 & 0 \\ -1 & 0 & 0 \end{bmatrix}$$
      </div>

      <div class="math-block">
        $$\begin{aligned}
        A_2 &= \begin{bmatrix} 0 & 0 & 1 \\ 0 & 1 & 0 \\ -1 & 0 & 0 \end{bmatrix}
        \begin{bmatrix} 1 \\ 0 \\ 0 \end{bmatrix} = \begin{bmatrix} 0 \\ 0 \\ -1 \end{bmatrix} \\
        B_2 &= \begin{bmatrix} 0 & 0 & 1 \\ 0 & 1 & 0 \\ -1 & 0 & 0 \end{bmatrix}
        \begin{bmatrix} 0 \\ 1 \\ 0 \end{bmatrix} = \begin{bmatrix} 0 \\ 1 \\ 0 \end{bmatrix} \\
        C_2 &= \begin{bmatrix} 0 & 0 & 1 \\ 0 & 1 & 0 \\ -1 & 0 & 0 \end{bmatrix}
        \begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix} = \begin{bmatrix} 1 \\ 0 \\ 0 \end{bmatrix} \\
        D_2 &= \begin{bmatrix} 0 \\ 0 \\ 0 \end{bmatrix}
        \end{aligned}$$
      </div>

      <p>
        <strong>Passo 3:</strong> Transladar de volta: T(1, 0, 0)
      </p>

      <div class="math-block">
        $$\begin{aligned}
        A' &= (0 + 1,\, 0,\, -1) = (1, 0, -1) \\
        B' &= (0 + 1,\, 1,\, 0) = (1, 1, 0) \\
        C' &= (1 + 1,\, 0,\, 0) = (2, 0, 0) \\
        D' &= (0 + 1,\, 0,\, 0) = (1, 0, 0)
        \end{aligned}$$
      </div>

      <p>
        O tetraedro foi rotacionado 90° em torno do eixo Y. O vértice D permaneceu fixo em (1, 0, 0),
        enquanto os demais vértices descreveram arcos de 90° ao redor deste ponto.
      </p>

      <h4>Demonstração 3D: Rotação a partir da Origem vs. Centróide</h4>

      <p>
        No espaço tridimensional, a rotação pode ocorrer em torno de diferentes eixos (X, Y ou Z).
        A demonstração abaixo mostra um cubo rotacionando em torno do eixo Y de duas formas:
      </p>

      <div class="demo-box">
        <div class="iframe-container">
          <iframe
            src="./rotacao_3d_comparacao.html"
            width="100%"
            height="450px"
            frameborder="0"
            title="Comparação de Rotação 3D: Origem vs Centróide"
            style="border: 1px solid #ddd; border-radius: 4px;">
          </iframe>
        </div>

        <p class="demo-note">
          <strong>Observação importante:</strong> À esquerda, o cubo orbita em torno da origem (0,0,0),
          descrevendo uma trajetória circular no espaço. À direita, o cubo gira em torno de seu próprio
          centro geométrico, permanecendo na mesma posição espacial.
        </p>
      </div>

      <h3 id="secao6-4">6.4 Centróide de Poliedros</h3>

      <p>
        O centróide (centro geométrico) de um poliedro com n vértices é calculado como:
      </p>

      <div class="math-block">
        $$\bar{x} = \frac{1}{n}\sum_{i=1}^{n} x_i, \quad
        \bar{y} = \frac{1}{n}\sum_{i=1}^{n} y_i, \quad
        \bar{z} = \frac{1}{n}\sum_{i=1}^{n} z_i$$
      </div>

      <p>
        <strong>Exemplo 6.3:</strong> Calcular o centróide do tetraedro com vértices A(1, 0, 0),
        B(0, 1, 0), C(0, 0, 1) e D(0, 0, 0):
      </p>

      <div class="math-block">
        $$\begin{aligned}
        \bar{x} &= \frac{1 + 0 + 0 + 0}{4} = 0.25 \\
        \bar{y} &= \frac{0 + 1 + 0 + 0}{4} = 0.25 \\
        \bar{z} &= \frac{0 + 0 + 1 + 0}{4} = 0.25
        \end{aligned}$$
      </div>

      <p>
        O centróide está em G(0.25, 0.25, 0.25). Para rotacionar este tetraedro em torno de seu centro,
        utilizaríamos P = G nas transformações com ponto fixo.
      </p>

      <h3 id="secao6-5">6.5 Aplicações em Gráficos 3D</h3>

      <p>
        Transformações geométricas 3D são fundamentais em:
      </p>

      <p>
        <strong>Modelagem 3D:</strong> Softwares CAD (AutoCAD, Blender) permitem manipular objetos
        através de transformações interativas. Cada operação de mover, rotacionar ou escalar aplica
        as matrizes.
      </p>

      <p>
        <strong>Animação:</strong> Engines como Unity e Unreal armazenam a transformação de cada
        objeto como componentes de posição (translação), rotação e escala.
        Animações interpolam entre estados de transformação ao longo do tempo.
      </p>

      <p>
        <strong>Scene Graphs:</strong> Estruturas hierárquicas onde transformações de objetos-pai
        afetam objetos-filhos. Por exemplo, em um modelo de braço robótico, rotacionar o ombro
        move automaticamente cotovelo e mão através de composição de matrizes.
      </p>

      <div class="theorem-box">
        <p>
          <strong>Coordenadas Locais vs. Globais:</strong> Em um scene graph, cada objeto possui
          transformação <strong>local</strong> (relativa ao pai) e <strong>global</strong>
          (relativa à origem do mundo). A transformação global é obtida multiplicando todas as
          matrizes da hierarquia desde a raiz até o objeto.
        </p>
      </div>
    </article>

    <div class="section-divider"></div>

    <!-- Métodos: WebGL -->
    <article id="secao7">
      <span class="section-label">7. Animação no Plano usando WebGL</span>
      <h2>Animação em WebGL</h2>

      <p>
        WebGL (Web Graphics Library) é uma API JavaScript que permite renderização de gráficos
        2D e 3D no navegador, executando nativamente na GPU sem necessidade de plugins. Baseada em
        OpenGL ES, possibilita criar aplicações gráficas de alta performance acessíveis diretamente
        pela web.
      </p>

      <h3 id="secao7-1">7.1 Pipeline de Renderização</h3>

      <p>
        O pipeline gráfico WebGL processa dados em cinco estágios principais:
      </p>

      <p>
        <strong>1. Dados de vértices:</strong> Arrays com posições, cores e atributos dos vértices.
      </p>

      <p>
        <strong>2. Vertex Shader:</strong> Programa executado na GPU que processa cada vértice individualmente,
        aplicando transformações e calculando a posição final.
      </p>

      <p>
        <strong>3. Rasterização:</strong> Converte primitivas geométricas (triângulos, linhas) em fragmentos (pixels).
      </p>

      <p>
        <strong>4. Fragment Shader:</strong> Define a cor de cada fragmento/pixel.
      </p>

      <p>
        <strong>5. Framebuffer:</strong> Imagem final exibida no canvas.
      </p>

      <!-- TODO: Adicionar diagrama do pipeline WebGL -->

      <h3 id="secao7-2">7.2 Sistema de Coordenadas WebGL</h3>

      <p>
        WebGL utiliza <strong>Normalized Device Coordinates (NDC)</strong>, um espaço de coordenadas
        normalizado onde todos os eixos variam de -1 a +1:
      </p>

      <div class="math-block">
        $$\text{NDC: } x, y, z \in [-1, 1]$$
      </div>

      <p>
        O centro do canvas está na origem (0, 0). O eixo X aumenta para direita, Y para cima,
        e Z para dentro da tela (sistema de mão direita).
      </p>

      <!-- TODO: Adicionar figura do sistema NDC -->

      <h3 id="secao7-3">7.3 Shaders: Programação na GPU</h3>

      <p>
        Shaders são pequenos programas escritos em GLSL (OpenGL Shading Language) que executam
        diretamente na GPU. Dois tipos são obrigatórios:
      </p>

      <h4>7.3.1 Vertex Shader</h4>

      <p>
        Processa cada vértice, calculando sua posição final e passando dados interpolados para
        o Fragment Shader:
      </p>

      <div class="code-block">
        <pre><code>attribute vec2 a_position;  // Posição do vértice
attribute vec4 a_color;     // Cor do vértice
varying vec4 v_color;       // Saída para fragment shader

void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
    v_color = a_color;
}</code></pre>
      </div>

      <p>
        <strong>Tipos de variáveis:</strong>
      </p>

      <p>
        <strong>attribute:</strong> Entrada por vértice (JavaScript → Vertex Shader).
      </p>

      <p>
        <strong>uniform:</strong> Valor constante para todos os vértices (parâmetros globais).
      </p>

      <p>
        <strong>varying:</strong> Saída interpolada entre vértices, passada ao Fragment Shader.
      </p>

      <p>
        <strong>gl_Position:</strong> Variável built-in que define a posição final do vértice (vec4).
      </p>

      <h4>7.3.2 Vertex Shader com Transformações</h4>

      <p>
        A implementação de transformações geométricas ocorre diretamente no Vertex Shader:
      </p>

      <div class="code-block">
        <pre><code>attribute vec2 a_position;
uniform vec2 u_translation;
uniform float u_rotation;
uniform vec2 u_scale;
uniform vec2 u_center;

void main() {
    vec2 position = a_position;

    // 1. Centralizar
    position = position - u_center;

    // 2. Rotação (matriz 2x2)
    float cosRot = cos(u_rotation);
    float sinRot = sin(u_rotation);
    position = vec2(
        position.x * cosRot - position.y * sinRot,
        position.x * sinRot + position.y * cosRot
    );

    // 3. Escala
    position = position * u_scale;

    // 4. Descentralizar
    position = position + u_center;

    // 5. Translação
    position = position + u_translation;

    gl_Position = vec4(position, 0.0, 1.0);
}</code></pre>
      </div>

      <div class="theorem-box">
        <p>
          <strong>Ordem de Transformações:</strong> A sequência correta é crucial. Rotação e escala
          ocorrem no espaço local (em torno do centróide), seguidas da translação que move o objeto
          já transformado para sua posição final. Alterar esta ordem produz resultados diferentes.
        </p>
      </div>

      <h4>7.3.3 Fragment Shader</h4>

      <p>
        Define a cor final de cada pixel através de interpolação automática dos valores varying:
      </p>

      <div class="code-block">
        <pre><code>precision mediump float;
varying vec4 v_color;

void main() {
    gl_FragColor = v_color;
}</code></pre>
      </div>

      <p>
        Valores varying são interpolados automaticamente entre vértices, permitindo gradientes
        suaves de cores.
      </p>

      <h3 id="secao7-4">7.4 Buffers: Enviando Dados à GPU</h3>

      <p>
        Buffers são áreas de memória na GPU que armazenam dados dos vértices. O processo envolve
        criar o buffer, vinculá-lo e copiar dados:
      </p>

      <div class="code-block">
        <pre><code>// 1. Definir vértices do triângulo
const vertices = [
     0.0,  0.5,   // Vértice superior
    -0.5, -0.5,   // Vértice inferior esquerdo
     0.5, -0.5    // Vértice inferior direito
];

// 2. Criar e vincular buffer
const vertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

// 3. Copiar dados para GPU
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);</code></pre>
      </div>

      <p>
        <strong>Tipos de uso:</strong>
      </p>

      <p>
        <strong>STATIC_DRAW:</strong> Dados definidos uma vez, usados muitas vezes.
      </p>

      <p>
        <strong>DYNAMIC_DRAW:</strong> Dados modificados ocasionalmente.
      </p>

      <p>
        <strong>STREAM_DRAW:</strong> Dados modificados a cada frame.
      </p>

      <h4>7.4.1 Conectando Buffers aos Attributes</h4>

      <div class="code-block">
        <pre><code>// Obter localização do attribute
const positionLoc = gl.getAttribLocation(program, 'a_position');

// Habilitar attribute
gl.enableVertexAttribArray(positionLoc);

// Especificar como ler dados do buffer
gl.vertexAttribPointer(
    positionLoc,  // Localização
    2,            // Componentes por vértice (x, y)
    gl.FLOAT,     // Tipo de dados
    false,        // Normalizar?
    0,            // Stride
    0             // Offset
);</code></pre>
      </div>

      <h3 id="secao7-5">7.5 Uniforms: Parâmetros Globais</h3>

      <p>
        Uniforms são variáveis constantes durante um draw call, usadas para transformações,
        tempo e outros parâmetros globais:
      </p>

      <div class="code-block">
        <pre><code>// Obter localização dos uniforms
const u_translation = gl.getUniformLocation(program, "u_translation");
const u_rotation = gl.getUniformLocation(program, "u_rotation");
const u_scale = gl.getUniformLocation(program, "u_scale");

// Definir valores
gl.uniform2f(u_translation, 0.5, 0.2);  // vec2
gl.uniform1f(u_rotation, Math.PI / 4);   // float
gl.uniform2f(u_scale, 1.5, 1.5);         // vec2</code></pre>
      </div>

      <h3 id="secao7-6">7.6 Loop de Renderização</h3>

      <p>
        O loop de renderização limpa o canvas, atualiza uniforms e desenha os objetos a cada frame:
      </p>

      <div class="code-block">
        <pre><code>function render() {
    // 1. Limpar canvas
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // 2. Atualizar uniforms
    gl.uniform2f(u_translation, x, y);

    // 3. Desenhar
    gl.drawArrays(gl.TRIANGLES, 0, 3);

    // 4. Próximo frame
    requestAnimationFrame(render);
}

render();</code></pre>
      </div>

      <p>
        <strong>gl.drawArrays(mode, first, count):</strong> Desenha primitivas usando vértices do buffer.
        O parâmetro mode define o tipo (gl.TRIANGLES, gl.TRIANGLE_FAN, gl.POINTS, etc.).
      </p>

      <h3 id="secao7-7">7.7 Exemplo Completo: Triângulo Animado</h3>

      <p>
        Implementação mínima completa de um triângulo rotacionando e se movendo em círculo:
      </p>

      <div class="code-block">
        <pre><code>// Setup inicial
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl');

// Shaders
const vsSource = `
    attribute vec2 a_position;
    uniform vec2 u_translation;
    uniform float u_rotation;

    void main() {
        float c = cos(u_rotation);
        float s = sin(u_rotation);
        vec2 pos = vec2(
            a_position.x * c - a_position.y * s,
            a_position.x * s + a_position.y * c
        );
        pos = pos + u_translation;
        gl_Position = vec4(pos, 0.0, 1.0);
    }
`;

const fsSource = `
    precision mediump float;
    void main() {
        gl_FragColor = vec4(0.2, 0.5, 0.8, 1.0);
    }
`;

// Compilar shaders e criar programa
// ... (código de compilação omitido)

// Dados e buffers
const vertices = new Float32Array([
     0.0,  0.5,
    -0.5, -0.5,
     0.5, -0.5
]);

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

// Conectar attributes
const a_position = gl.getAttribLocation(program, 'a_position');
gl.enableVertexAttribArray(a_position);
gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const u_translation = gl.getUniformLocation(program, "u_translation");
const u_rotation = gl.getUniformLocation(program, "u_rotation");

// Animação
let angle = 0;

function render() {
    gl.clearColor(0.1, 0.1, 0.1, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    angle += 0.02;
    const x = Math.cos(angle) * 0.5;
    const y = Math.sin(angle) * 0.5;

    gl.uniform2f(u_translation, x, y);
    gl.uniform1f(u_rotation, angle);

    gl.drawArrays(gl.TRIANGLES, 0, 3);
    requestAnimationFrame(render);
}

render();</code></pre>
      </div>

      <h3 id="secao7-8">7.8 Relação com Álgebra Linear</h3>

      <p>
        A correspondência direta entre conceitos matemáticos e implementação WebGL demonstra
        a aplicação prática da álgebra linear:
      </p>

      <table style="width: 100%; border-collapse: collapse; margin: 1.5rem 0;">
        <thead>
          <tr style="background: var(--bg-light); border-bottom: 2px solid var(--border-dark);">
            <th style="padding: 0.75rem; text-align: left; font-weight: 600;">Conceito Matemático</th>
            <th style="padding: 0.75rem; text-align: left; font-weight: 600;">Implementação WebGL</th>
          </tr>
        </thead>
        <tbody>
          <tr style="border-bottom: 1px solid var(--border);">
            <td style="padding: 0.75rem;">Vetor em ℝ²</td>
            <td style="padding: 0.75rem;"><code>attribute vec2 a_position</code></td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border);">
            <td style="padding: 0.75rem;">Matriz 2×2</td>
            <td style="padding: 0.75rem;">Rotação/Escala no vertex shader</td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border);">
            <td style="padding: 0.75rem;">Transformação linear</td>
            <td style="padding: 0.75rem;">Operações no espaço local (centróide)</td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border);">
            <td style="padding: 0.75rem;">Transformação afim</td>
            <td style="padding: 0.75rem;">Translação (não preserva origem)</td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border);">
            <td style="padding: 0.75rem;">Composição de transformações</td>
            <td style="padding: 0.75rem;">Sequência de operações no shader</td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border);">
            <td style="padding: 0.75rem;">Espaço vetorial</td>
            <td style="padding: 0.75rem;">Sistema de coordenadas NDC</td>
          </tr>
          <tr>
            <td style="padding: 0.75rem;">Produto matriz-vetor</td>
            <td style="padding: 0.75rem;">Aplicação de transformações</td>
          </tr>
        </tbody>
      </table>

      <div class="example-box">

        <p><strong>Escala com ponto fixo - WebGL (vertex shader):</strong></p>
        <div class="code-block">
          <pre><code>position = a_position - u_center;  // T(-cx, -cy)
position = position * u_scale;      // S(sx, sy)
position = position + u_center;     // T(cx, cy)</code></pre>
        </div>

        <p>
          Correspondência direta entre teoria matemática e código.
        </p>
      </div>

      <h3 id="secao7-9">7.9 Aplicação Prática</h3>

      <p>
        A demonstração abaixo integra todos os conceitos apresentados: buffers, shaders, uniforms,
        transformações e loop de renderização. O sistema permite adicionar polígonos (triângulo,
        quadrado, pentágono, hexágono) e aplicar transformações interativas através de controles
        na barra lateral.
      </p>

      <p>
        Cada objeto mantém seu estado de transformação (translação, rotação, escala) e pode ser
        manipulado independentemente, criando o movimento fluido.
      </p>

      <div class="demo-box">
        <div class="iframe-container">
          <iframe
            src="./animation2d/index.html"
            width="720px"
            height="720px"
            frameborder="0"
            title="Animação no Plano"
            style="border: 1px solid #ddd; border-radius: 4px;">
          </iframe>
        </div>
      </div>

    </article>

    <div class="section-divider"></div>

    <!-- WebGL 3D -->
    <article id="secao8">
      <span class="section-label">8. Animação no Espaço</span>
      <h2>Extensão para o Espaço Tridimensional</h2>

      <p>
        A Seção 7 demonstrou transformações 2D aplicadas diretamente no vertex shader. Em 3D,
        adotamos uma abordagem diferente: matrizes de transformação calculadas no JavaScript
        e passadas como uniforms, seguindo o pipeline Model-View-Projection (MVP). Esta mudança
        permite hierarquia de objetos (scene graph).
      </p>

      <h3 id="secao8-1">8.1 Diferenças Fundamentais entre 2D e 3D</h3>

      <p>
        <strong>Coordenadas:</strong> Seção 7.2 introduziu vec2 (x, y) no espaço NDC [-1, 1]².
        Em 3D, vec3 (x, y, z) opera em [-1, 1]³, adicionando profundidade.
      </p>

      <p>
        <strong>Projeção:</strong> Em 2D (Seção 7.2), gl_Position recebe vec2 diretamente, mapeando
        para o canvas sem transformação adicional. Em 3D, uma matriz de projeção perspectiva 4×4
        converte vec3 → vec2, simulando profundidade.
      </p>

      <p>
        <strong>Visibilidade:</strong> Na Seção 7.9, a ordem de chamadas drawObject() define
        sobreposição. Em 3D, <code>gl.enable(gl.DEPTH_TEST)</code> ativa o Z-buffer: cada pixel
        armazena sua profundidade, e fragmentos mais próximos sobrescrevem distantes automaticamente.
      </p>

      <p>
        <strong>Transformações:</strong> A Seção 7.3.2 aplicava transformações inline no shader
        (cos/sin diretos). Em 3D, calculamos matrizes 4×4 e as passamos como uniforms, permitindo 
        hierarquia de objetos.
      </p>

      <p>
        <strong>Pipeline MVP:</strong> Enquanto 2D mapeia diretamente vértices para NDC, 3D usa
        três transformações sequenciais: Model (espaço local → mundo), View (mundo → câmera),
        Projection (câmera → NDC). Detalhado nas seções 8.2 e 8.4.
      </p>

      <h3 id="secao8-2">8.2 Geometria 3D: Poliedros</h3>

      <p>
        Poliedros são representados por vértices e índices. Um cubo possui 8 vértices, mas suas
        6 faces requerem 12 triângulos (2 por face). Índices permitem reutilizar vértices:
      </p>

      <div class="code-block">
        <pre><code>// Vértices do cubo (8 pontos)
const cubeVertices = [
    -0.5, -0.5,  0.5,  // 0: front-bottom-left
     0.5, -0.5,  0.5,  // 1: front-bottom-right
     0.5,  0.5,  0.5,  // 2: front-top-right
    -0.5,  0.5,  0.5,  // 3: front-top-left
    -0.5, -0.5, -0.5,  // 4: back-bottom-left
    -0.5,  0.5, -0.5,  // 5: back-top-left
     0.5,  0.5, -0.5,  // 6: back-top-right
     0.5, -0.5, -0.5   // 7: back-bottom-right
];

// Índices (12 triângulos)
const cubeIndices = [
    0, 1, 2,  0, 2, 3,  // Front face
    4, 5, 6,  4, 6, 7,  // Back face
    // ... (outras 4 faces)
];</code></pre>
      </div>

      <h3 id="secao8-3">8.3 Vertex Shader 3D: Pipeline MVP</h3>

      <p>
        Diferente da Seção 7.3.2 (transformações inline no shader), em 3D o vertex shader recebe 
        três matrizes uniformes e aplica a composição Model-View-Projection:
      </p>

      <div class="code-block">
        <pre><code>attribute vec3 aPosition;
attribute vec3 aNormal;

uniform mat4 uModelMatrix;      // Transformação local → mundo
uniform mat4 uViewMatrix;       // Transformação mundo → câmera
uniform mat4 uProjectionMatrix; // Transformação câmera → NDC
uniform mat4 uNormalMatrix;     // Transforma normais (iluminação)

varying vec3 vNormal;
varying vec3 vPosition;

void main() {
    // Posição no espaço do mundo
    vec4 worldPosition = uModelMatrix * vec4(aPosition, 1.0);
    vPosition = worldPosition.xyz;

    // Normal transformada (sem translação/escala)
    vNormal = (uNormalMatrix * vec4(aNormal, 0.0)).xyz;

    // Pipeline MVP completo
    gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;
}</code></pre>
      </div>

      <p>
        <strong>Mudança fundamental:</strong> Enquanto a Seção 7.3.2 aplicava cos/sin diretamente
        no shader, aqui delegamos o cálculo de matrizes ao JavaScript. Isso permite composição
        hierárquica (filhos herdam transformações dos pais) e simplifica o shader.
      </p>

      <p>
        A matriz normal (<code>uNormalMatrix</code>) é a transposta da inversa da matriz model,
        necessária para transformar vetores normais corretamente quando há escala não uniforme.
      </p>

      <h3 id="secao8-4">8.4 Iluminação</h3>

      <p>
        Iluminação em 3D combina três componentes: ambiente (luz constante), difusa (proporcional
        ao ângulo entre normal e luz), e especular (reflexos brilhantes).
      </p>

      <div class="code-block">
        <pre><code>precision mediump float;

varying vec3 v_color;
varying vec3 v_normal;
varying vec3 v_fragPos;

uniform vec3 u_lightPos;
uniform vec3 u_viewPos;

void main() {
    vec3 norm = normalize(v_normal);
    vec3 lightDir = normalize(u_lightPos - v_fragPos);
    vec3 viewDir = normalize(u_viewPos - v_fragPos);

    // Componente ambiente
    float ambientStrength = 0.3;
    vec3 ambient = ambientStrength * v_color;

    // Componente difusa (Lei de Lambert)
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * v_color;

    // Componente especular (Phong)
    vec3 reflectDir = reflect(-lightDir, norm);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
    vec3 specular = vec3(0.5) * spec;

    vec3 result = ambient + diffuse + specular;
    gl_FragColor = vec4(result, 1.0);
}</code></pre>
      </div>

      <h3 id="secao8-5">8.5 Comparação: Aplicações 2D vs 3D</h3>

      <table style="width: 100%; border-collapse: collapse; margin: 1.5rem 0;">
        <thead>
          <tr style="background: var(--bg-light); border-bottom: 2px solid var(--border-dark);">
            <th style="padding: 0.75rem; text-align: left; font-weight: 600;">Aspecto</th>
            <th style="padding: 0.75rem; text-align: left; font-weight: 600;">2D (Seção 7.9)</th>
            <th style="padding: 0.75rem; text-align: left; font-weight: 600;">3D (Seção 8.11)</th>
          </tr>
        </thead>
        <tbody>
          <tr style="border-bottom: 1px solid var(--border);">
            <td style="padding: 0.75rem;">Coordenadas</td>
            <td style="padding: 0.75rem;">vec2 (x, y) no plano</td>
            <td style="padding: 0.75rem;">vec3 (x, y, z) no espaço</td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border);">
            <td style="padding: 0.75rem;">Projeção</td>
            <td style="padding: 0.75rem;">Implícita (NDC direto)</td>
            <td style="padding: 0.75rem;">Explícita (matriz 4×4 perspectiva)</td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border);">
            <td style="padding: 0.75rem;">Visibilidade</td>
            <td style="padding: 0.75rem;">Ordem de desenho</td>
            <td style="padding: 0.75rem;">Depth Test (Z-buffer)</td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border);">
            <td style="padding: 0.75rem;">Rotações</td>
            <td style="padding: 0.75rem;">Um ângulo (em torno de Z)</td>
            <td style="padding: 0.75rem;">Três ângulos (X, Y, Z)</td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border);">
            <td style="padding: 0.75rem;">Organização</td>
            <td style="padding: 0.75rem;">Lista plana de objetos</td>
            <td style="padding: 0.75rem;">Hierarquia (pais/filhos)</td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border);">
            <td style="padding: 0.75rem;">Câmera</td>
            <td style="padding: 0.75rem;">Fixa (observador estático)</td>
            <td style="padding: 0.75rem;">Orbital</td>
          </tr>
        </tbody>
      </table>

      <p>
        <strong>Observação:</strong> A abordagem do Vertex Shader (Seção 7.3.2) é mantida em 3D,
        aplicando transformações diretamente na GPU. A diferença fundamental é a adição da coordenada
        Z e da matriz de projeção perspectiva.
      </p>

      <h3 id="secao8-6">8.6 Relação com Álgebra Linear</h3>

      <table style="width: 100%; border-collapse: collapse; margin: 1.5rem 0;">
        <thead>
          <tr style="background: var(--bg-light); border-bottom: 2px solid var(--border-dark);">
            <th style="padding: 0.75rem; text-align: left; font-weight: 600;">Conceito Matemático</th>
            <th style="padding: 0.75rem; text-align: left; font-weight: 600;">Implementação WebGL 3D</th>
          </tr>
        </thead>
        <tbody>
          <tr style="border-bottom: 1px solid var(--border);">
            <td style="padding: 0.75rem;">Vetor em ℝ³</td>
            <td style="padding: 0.75rem;"><code>attribute vec3 a_position</code></td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border);">
            <td style="padding: 0.75rem;">Produto escalar</td>
            <td style="padding: 0.75rem;"><code>dot(normal, lightDir)</code> para iluminação</td>
          </tr>
          <tr style="border-bottom: 1px solid var(--border);">
            <td style="padding: 0.75rem;">Produto vetorial</td>
            <td style="padding: 0.75rem;"><code>cross(up, forward)</code> para câmera</td>
          </tr>
          <tr>
            <td style="padding: 0.75rem;">Mudança de base</td>
            <td style="padding: 0.75rem;">Coordenadas locais → globais</td>
          </tr>
        </tbody>
      </table>

      <div class="theorem-box">
        <p>
          <strong>Hierarquia de Transformações:</strong> A matriz global de um objeto filho é
          o produto da matriz do pai pela matriz local do filho. Esta composição propaga
          transformações pela hierarquia do scene graph, fundamental para animação de personagens
          articulados.
        </p>
      </div>

      <h3 id="secao8-7">8.7 Animação Coelho</h3>

      <p>
        A demonstração abaixo aplica os conceitos da Seção 7 (transformações no vertex shader, buffers,
        loop de animação) ao espaço tridimensional. Diferente da aplicação 2D que usa objetos independentes,
        aqui cada parte do coelho tem transformações coordenadas que criam movimento coerente.
      </p>

      <div class="demo-box">
        <iframe
          src="./animation3d/index.html"
          width="700"
          height="700"
          style="border: none; border-radius: 8px;"
        ></iframe>
      </div>

      <div class="example-box">
        <p><strong>Extensões 2D → 3D Implementadas:</strong></p>
        <ul>
          <li><strong>Coordenadas vec3:</strong> 12 partes (corpo, cabeça, 2 orelhas, 4 patas, rabo, 2 olhos, nariz) com posição (x, y, z)</li>
          <li><strong>Depth Test:</strong> <code>gl.enable(gl.DEPTH_TEST)</code> garante que partes frontais ocultam traseiras</li>
          <li><strong>Projeção perspectiva:</strong> Matriz 4×4 simula distância (objetos distantes menores)</li>
          <li><strong>Rotações 3D:</strong> Aplicadas em X, Y, Z sequencialmente no vertex shader</li>
          <li><strong>Animação coordenada:</strong> Pulo sincroniza movimento vertical do corpo com alternância de patas</li>
          <li><strong>Câmera interativa:</strong> Mouse rotaciona ao redor do coelho (órbita esférica)</li>
        </ul>
      </div>

      <div class="theorem-box">
        <ul>
          <li><strong>vec2 → vec3:</strong> Adicionar coordenada Z e profundidade</li>
          <li><strong>Transformações no shader:</strong> Mesma abordagem da Seção 7.3.2, mas com rotações tridimensionais</li>
          <li><strong>Projeção explícita:</strong> Matriz perspectiva transforma vec3 mundo → vec2 tela</li>
          <li><strong>Hierarquia simples:</strong> Transformações propagam de pais para filhos (corpo influencia patas)</li>
        </ul>
      </div>
    </article>

    <article id="secao9">
      <h2>9. Sistema de Animação Interativa</h2>

      <p>
        Esta seção complementa o estudo apresentando um sistema que permite manipular
        transformações, combinando os conceitos de álgebra linear com programação.
      </p>

      <h3 id="secao9-1">9.1 Arquitetura do Sistema</h3>

      <p>
        O sistema implementa uma arquitetura composta por três componentes
        principais que operam em conjunto no loop de renderização WebGL:
      </p>

      <div class="example-box">
        <p><strong>Componentes do Sistema:</strong></p>
        <ul>
          <li><strong>Gerenciador de Objetos (DrawableObject):</strong> Encapsula vértices, cores e estado de transformação de cada polígono</li>
          <li><strong>Interface de Controle:</strong> Permite adicionar objetos e configurar parâmetros de transformação (X, Y, E, R)</li>
          <li><strong>Motor de Animação:</strong> Aplica transformações incrementais a cada frame e executa código customizado</li>
        </ul>
      </div>

      <p>
        Diferente das demonstrações anteriores, onde as transformações eram pré-programadas e específicas
        para cada exemplo, este oferece controle sobre cada objeto renderizado.
        O usuário define incrementos de translação (X, Y), escala (E) e rotação (R) que são aplicados
        continuamente no loop de animação.
      </p>

      <div class="code-block">
        <pre><code>class DrawableObject {
  constructor(vertices, colors, drawType) {
    this.vertices = vertices;
    this.colors = colors;
    this.translation = {x: 0, y: 0};
    this.rotation = 0;
    this.scale = {x: 1, y: 1};
    this.animation = {x: 0, y: 0, ex: 0, ey: 0, r: 0};
    this.customCodeFunction = null;
    this.calculateCenter(this.vertices);
  }
}</code></pre>
      </div>

      <p>
        A classe armazena tanto o estado atual da transformação (<code>translation</code>, <code>rotation</code>,
        <code>scale</code>) quanto os incrementos (<code>animation</code>) aplicados por frame. O centróide
        calculado em <code>this.center</code>.
      </p>

      <h3 id="secao9-2">9.2 Gerenciamento de Estado</h3>

      <p>
        O sistema mantém um array global <code>objectsToDraw[]</code> que armazena todos os objetos ativos.
        A cada chamada de <code>requestAnimationFrame()</code>, a função <code>runAnimation()</code> itera
        sobre os objetos e atualiza seu estado de transformação:
      </p>

      <div class="code-block">
        <pre><code>function runAnimation() {
  for(let object of objectsToDraw) {
    let currentX = object.translation.x + object.animation.x;
    let currentY = object.translation.y + object.animation.y;
    let currentEX = object.scale.x + object.animation.ex;
    let currentEY = object.scale.y + object.animation.ey;
    let currentR = object.rotation + object.animation.r;

    object.setTranslation(currentX, currentY);
    object.setScale(currentEX, currentEY);
    object.setRotation(currentR);
  }
}</code></pre>
      </div>

      <p>
        Esta abordagem implementa <strong>animação procedural</strong>: em vez de definir
        posições absolutas, o sistema soma incrementos ao estado anterior, para uma sequência
        de frames \(t = 0, 1, 2, \ldots\), a translação no eixo X evolui como:
      </p>

      <div class="theorem-box">
        <p>
          <strong>Composição de Transformações no Vertex Shader:</strong> O vertex shader aplica as
          transformações na ordem pivot → rotação → escala → translação final. Quando o modo de centróide
          está ativo (<code>isCenter = true</code>), o pivô é ajustado para <code>u_center + u_translation</code>,
          garantindo que rotação e escala ocorram em torno do centro transladado do objeto.
        </p>
      </div>

      <h3 id="secao9-3">9.3 Animação Procedural via Código</h3>

      <p>
        Além dos parâmetros de incremento fixos (X, Y, E, R), o sistema permite uma funcionalidade de
        <strong>programação por objeto</strong>. Cada objeto possui uma área de código JavaScript
        onde o usuário pode definir transformações dinâmicas baseadas em funções.
      </p>

      <div class="code-block">
        <pre><code>// Exemplo de código customizado para rotação senoidal
object.setRotation(Math.sin(angle) * 0.5);

// Exemplo de movimento circular
object.setTranslation(
  Math.cos(angle) * 0.3,
  Math.sin(angle) * 0.3
);</code></pre>
      </div>

      <p>
        O código é compilado via <code>new Function('object', 'angle', code)</code> e executado a cada frame
        antes da renderização. O escopo da função recebe duas variáveis:
      </p>

      <div class="example-box">
        <ul>
          <li><strong>object:</strong> Referência ao DrawableObject, permitindo chamar <code>setTranslation(x, y)</code>, <code>setRotation(r)</code> e <code>setScale(x, y)</code></li>
          <li><strong>angle:</strong> Contador global que incrementa 0.02 radianos por frame, útil para funções periódicas</li>
        </ul>
      </div>

      <p>
        onde \(A\) é a amplitude, \(\omega\) a frequência angular e \(\phi\) a fase inicial. Com \(\phi_y = \phi_x + \pi/2\),
        obtém-se trajetória circular de raio \(A\), demonstrando a aplicação de séries de Fourier a gráficos computacionais.
      </p>

      <div class="theorem-box">
        <p>
          <strong>Tratamento de Erros:</strong> O sistema valida o código em tempo de compilação. Erros de sintaxe
          são capturados no <code>try-catch</code> do construtor <code>Function()</code>, enquanto erros de execução
          (ex: referências indefinidas) são tratados no método <code>executeCustomCode()</code>. A interface exibe
          mensagens de erro específicas.
        </p>
      </div>

      <h3 id="secao9-4">9.4 Aplicação Prática Interativa</h3>

      <p>
        A demonstração abaixo integra todos os conceitos das seções anteriores em uma ferramenta interativa
        de autoria de animações. O usuário pode adicionar polígonos (triângulo, quadrado, pentágono, hexágono),
        ajustar transformações via controles numéricos, e programar comportamentos customizados via JavaScript.
      </p>

      <div class="demo-box" style="display: flex; justify-content: center; padding: 1rem 0;">
        <iframe
          src="./animationInteractiv/index.html"
          width="1000"
          height="650"
          style="border: none; border-radius: 8px; min-width: 1000px;"
        ></iframe>
      </div>

      <p class="demo-note">
        <strong>Instruções de uso:</strong> Clique nos ícones de formas geométricas à esquerda para adicionar objetos.
        Para cada objeto, ajuste os parâmetros X (translação horizontal), Y (translação vertical), E (escala) e
        R (rotação) para definir incrementos por frame. Expanda "Anime com Código Customizado (JS)" para programar
        transformações dinâmicas usando funções trigonométricas e a variável <code>angle</code>.
      </p>

      <div class="example-box">
        <p><strong>Exercícios Sugeridos:</strong></p>
        <ol>
          <li>Crie um quadrado e configure R = 0.02 para observar rotação uniforme em torno do centróide</li>
          <li>Use código customizado <code>object.setScale(1 + Math.sin(angle) * 0.3, 1 + Math.sin(angle) * 0.3)</code> para pulsação periódica</li>
          <li>Combine translação incremental (X = 0.005) com rotação customizada para movimento helicoidal</li>
          <li>Adicione múltiplos pentágonos com fases diferentes: <code>Math.sin(angle + 0.5 * id)</code> para efeito cascata</li>
        </ol>
      </div>

    </article>

    <article id="secao10">
      <h2>10. Conclusão</h2>

      <p>
        Este trabalho apresentou a conexão entre álgebra linear e computação gráfica através de uma
        abordagem prática e interativa. Iniciamos pelos fundamentos matemáticos de transformações lineares
        em ℝ² e ℝ³, avançamos para transformações geométricas com pontos fixos arbitrários, e implementamos
        esses conceitos em WebGL, culminando em um sistema interativo de animação.
      </p>

      <p>
        O principal objetivo deste trabalho é conectar teoria e prática de forma tangível: cada
        transformação matemática tem correspondência direta no código WebGL, e cada demonstração permite
        experimentação.
      </p>

      <h3 id="secao10-1">10.1 Importância e Aplicações</h3>

      <p>
        Este trabalho serve como ferramenta para disciplinas de Álgebra Linear e Computação Gráfica,
        permitindo que estudantes visualizem conceitos e experimentem diferentes transformações em.
      </p>

      <p>
        A implementação em WebGL demonstra aplicação prática de álgebra linear, fortalecendo
        o estudo de conceitos matemáticos através de resultados visuais. O código-fonte aberto
        permite adaptação e extensão por educadores e alunos.
      </p>

      <h3 id="secao10-2">10.2 Trabalhos Futuros</h3>

      <p>
        Diversas extensões podem ampliar o alcance deste trabalho:
      </p>

      <ul>
        <li><strong>Sistema 3D interativo:</strong> Generalizar a ferramenta da seção 9 para poliedros, permitindo manipulação de objetos tridimensionais com câmera orbital e iluminação</li>
        <li><strong>Coordenadas homogêneas:</strong> Adicionar seção sobre matrizes 4×4 e como unificam transformações afins</li>
        <li><strong>Estudo de eficácia:</strong> Realizar pesquisa analisando aprendizado com a ferramenta</li>
      </ul>

      <p>
        Espero que este material contribua para o ensino de álgebra linear aplicada à computação gráfica.
      </p>
    </article>
  </main>

  <!-- Footer -->
  <footer>
    <div class="footer-content">
      <div class="author-info">
        <strong>Autor:</strong> Calebe Holanda Amaral
      </div>
      <div class="author-info">
        <strong>Orientadora:</strong> Profa. Dra. Hellena Christina Fernandes Apolinário
      </div>
      <div class="footer-institution">
        Universidade Federal do Tocantins - UFT
      </div>
    </div>
  </footer>

  <script>
    window.addEventListener('scroll', () => {
      const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
      const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
      const scrolled = (winScroll / height) * 100;
      document.getElementById('progressBar').style.width = scrolled + '%';
      document.getElementById('tocProgressFill').style.width = scrolled + '%';

      updateActiveSection();
    });

    function updateActiveSection() {
      const sections = document.querySelectorAll('article[id], h3[id]');
      const tocItems = document.querySelectorAll('.toc-item');

      let currentSection = '';
      const scrollPosition = window.scrollY + 200;

      sections.forEach(section => {
        const sectionTop = section.offsetTop;
        const sectionHeight = section.offsetHeight;

        if (scrollPosition >= sectionTop && scrollPosition < sectionTop + sectionHeight) {
          currentSection = section.id;
        }
      });

      tocItems.forEach(item => {
        item.classList.remove('active');
        if (item.getAttribute('href') === '#' + currentSection) {
          item.classList.add('active');
        }
      });
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener('click', function (e) {
        e.preventDefault();
        const target = document.querySelector(this.getAttribute('href'));
        if (target) {
          target.scrollIntoView({ behavior: 'smooth', block: 'start' });

          if (window.innerWidth <= 1024) {
            document.getElementById('tocSidebar').classList.remove('open');
          }
        }
      });
    });

    document.getElementById('tocToggle').addEventListener('click', () => {
      document.getElementById('tocSidebar').classList.toggle('open');
    });

    document.getElementById('tocCollapseBtn').addEventListener('click', () => {
      const sidebar = document.getElementById('tocSidebar');
      const collapseBtn = document.getElementById('tocCollapseBtn');
      const body = document.body;

      sidebar.classList.toggle('collapsed');
      body.classList.toggle('sidebar-collapsed');
      collapseBtn.classList.toggle('collapsed');

      if (sidebar.classList.contains('collapsed')) {
        collapseBtn.textContent = '▶';
        collapseBtn.title = 'Expandir menu';
      } else {
        collapseBtn.textContent = '◀';
        collapseBtn.title = 'Recolher menu';
      }
    });

    document.addEventListener('click', (e) => {
      const sidebar = document.getElementById('tocSidebar');
      const toggle = document.getElementById('tocToggle');

      if (window.innerWidth <= 1024 &&
          sidebar.classList.contains('open') &&
          !sidebar.contains(e.target) &&
          !toggle.contains(e.target)) {
        sidebar.classList.remove('open');
      }
    });

    updateActiveSection();
  </script>
</body>
</html>