<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Comparação 3D: Rotação com e sem Centróide</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: white;
      padding: 20px;
    }

    h2 {
      text-align: center;
      color: #1e293b;
      margin-bottom: 20px;
      font-size: 20px;
      font-weight: 700;
    }

    .comparison {
      display: table;
      width: 100%;
      table-layout: fixed;
    }

    .canvas-box {
      display: table-cell;
      text-align: center;
      padding: 0 15px;
      vertical-align: top;
    }

    .canvas-box h3 {
      font-size: 14px;
      color: #475569;
      margin-bottom: 10px;
      font-weight: 600;
    }

    canvas {
      display: block;
      width: 300px;
      height: 300px;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    }

    .rotation-indicator {
      margin-top: 10px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      color: #64748b;
      font-weight: 600;
    }

    .rotation-value {
      color: #3b82f6;
      font-size: 16px;
    }

    @media (max-width: 900px) {
      .comparison {
        display: block;
      }

      .canvas-box {
        margin-bottom: 30px;
      }

      .canvas-box:last-child {
        margin-bottom: 0;
      }

      canvas {
        margin: 0 auto;
      }
    }
  </style>
</head>
<body>
  <h2>Rotação 3D: Origem vs. Centróide</h2>

  <div class="comparison">
    <div class="canvas-box">
      <h3>Rotação a partir da Origem</h3>
      <canvas id="canvasOrigin" width="300" height="300"></canvas>
      <div class="rotation-indicator">Ângulo: <span class="rotation-value" id="angleOrigin">0°</span></div>
    </div>

    <div class="canvas-box">
      <h3>Rotação a partir do Centróide</h3>
      <canvas id="canvasCentroid" width="300" height="300"></canvas>
      <div class="rotation-indicator">Ângulo: <span class="rotation-value" id="angleCentroid">0°</span></div>
    </div>
  </div>

  <script>
    const vsSource = `
      attribute vec3 aPosition;
      attribute vec3 aColor;
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;
      uniform mat4 uRotationMatrix;
      uniform vec3 uCentroid;
      uniform bool uUseCentroid;
      varying vec3 vColor;

      void main(void) {
        vec4 pos = vec4(aPosition, 1.0);

        if (uUseCentroid) {
          // Translate to origin, rotate, translate back
          pos = vec4(aPosition - uCentroid, 1.0);
          pos = uRotationMatrix * pos;
          pos = vec4(pos.xyz + uCentroid, 1.0);
        } else {
          // Rotate around origin
          pos = uRotationMatrix * pos;
        }

        gl_Position = uProjectionMatrix * uModelViewMatrix * pos;
        vColor = aColor;
      }
    `;

    const fsSource = `
      precision mediump float;
      varying vec3 vColor;

      void main(void) {
        gl_FragColor = vec4(vColor, 1.0);
      }
    `;

    let glOrigin, glCentroid;
    let programOrigin, programCentroid;
    let buffersOrigin, buffersCentroid;
    let angle = 0;
    let animationSpeed = 0.02;

    // Cube vertices offset from origin
    const cubeVertices = new Float32Array([
      // Front face
      0.0, -0.5,  0.5,
      1.0, -0.5,  0.5,
      1.0,  0.5,  0.5,
      0.0,  0.5,  0.5,
      // Back face
      0.0, -0.5, -0.5,
      0.0,  0.5, -0.5,
      1.0,  0.5, -0.5,
      1.0, -0.5, -0.5,
      // Top face
      0.0,  0.5, -0.5,
      0.0,  0.5,  0.5,
      1.0,  0.5,  0.5,
      1.0,  0.5, -0.5,
      // Bottom face
      0.0, -0.5, -0.5,
      1.0, -0.5, -0.5,
      1.0, -0.5,  0.5,
      0.0, -0.5,  0.5,
      // Right face
      1.0, -0.5, -0.5,
      1.0,  0.5, -0.5,
      1.0,  0.5,  0.5,
      1.0, -0.5,  0.5,
      // Left face
      0.0, -0.5, -0.5,
      0.0, -0.5,  0.5,
      0.0,  0.5,  0.5,
      0.0,  0.5, -0.5,
    ]);

    const cubeColors = new Float32Array([
      // Front face
      0.5, 0.55, 0.6,  0.5, 0.55, 0.6,  0.5, 0.55, 0.6,  0.5, 0.55, 0.6,
      // Back face
      0.4, 0.45, 0.5,  0.4, 0.45, 0.5,  0.4, 0.45, 0.5,  0.4, 0.45, 0.5,
      // Top face
      0.6, 0.65, 0.7,  0.6, 0.65, 0.7,  0.6, 0.65, 0.7,  0.6, 0.65, 0.7,
      // Bottom face
      0.35, 0.4, 0.45,  0.35, 0.4, 0.45,  0.35, 0.4, 0.45,  0.35, 0.4, 0.45,
      // Right face
      0.55, 0.6, 0.65,  0.55, 0.6, 0.65,  0.55, 0.6, 0.65,  0.55, 0.6, 0.65,
      // Left face
      0.45, 0.5, 0.55,  0.45, 0.5, 0.55,  0.45, 0.5, 0.55,  0.45, 0.5, 0.55,
    ]);

    const cubeIndices = new Uint16Array([
      0,  1,  2,    0,  2,  3,    // front
      4,  5,  6,    4,  6,  7,    // back
      8,  9,  10,   8,  10, 11,   // top
      12, 13, 14,   12, 14, 15,   // bottom
      16, 17, 18,   16, 18, 19,   // right
      20, 21, 22,   20, 22, 23,   // left
    ]);

    const centroid = [0.5, 0, 0];

    function initWebGL(canvas) {
      const gl = canvas.getContext('webgl', { antialias: true, alpha: false });
      if (!gl) {
        alert('WebGL não está disponível.');
        return null;
      }
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      return gl;
    }

    function initShaderProgram(gl, vsSource, fsSource) {
      const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);
      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        console.error('Shader program failed: ' + gl.getProgramInfoLog(shaderProgram));
        return null;
      }
      return shaderProgram;
    }

    function loadShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error: ' + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function initBuffers(gl) {
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);

      const colorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, cubeColors, gl.STATIC_DRAW);

      const indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);

      return { position: positionBuffer, color: colorBuffer, indices: indexBuffer };
    }

    function mat4Perspective(out, fovy, aspect, near, far) {
      const f = 1.0 / Math.tan(fovy / 2);
      out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
      out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
      out[8] = 0; out[9] = 0; out[10] = (far + near) / (near - far); out[11] = -1;
      out[12] = 0; out[13] = 0; out[14] = (2 * far * near) / (near - far); out[15] = 0;
    }

    function mat4LookAt(out, eye, center, up) {
      const z0 = eye[0] - center[0], z1 = eye[1] - center[1], z2 = eye[2] - center[2];
      let len = Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
      const zx = z0 / len, zy = z1 / len, zz = z2 / len;

      const x0 = up[1] * zz - up[2] * zy;
      const x1 = up[2] * zx - up[0] * zz;
      const x2 = up[0] * zy - up[1] * zx;
      len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
      const xx = x0 / len, xy = x1 / len, xz = x2 / len;

      const yx = zy * xz - zz * xy;
      const yy = zz * xx - zx * xz;
      const yz = zx * xy - zy * xx;

      out[0] = xx; out[1] = yx; out[2] = zx; out[3] = 0;
      out[4] = xy; out[5] = yy; out[6] = zy; out[7] = 0;
      out[8] = xz; out[9] = yz; out[10] = zz; out[11] = 0;
      out[12] = -(xx * eye[0] + xy * eye[1] + xz * eye[2]);
      out[13] = -(yx * eye[0] + yy * eye[1] + yz * eye[2]);
      out[14] = -(zx * eye[0] + zy * eye[1] + zz * eye[2]);
      out[15] = 1;
    }

    function mat4RotateY(out, angle) {
      const c = Math.cos(angle), s = Math.sin(angle);
      out[0] = c; out[1] = 0; out[2] = s; out[3] = 0;
      out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
      out[8] = -s; out[9] = 0; out[10] = c; out[11] = 0;
      out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
    }

    function drawScene(gl, programInfo, buffers, useCentroid, currentAngle) {
      gl.clearColor(0.97, 0.98, 0.99, 1.0);
      gl.clearDepth(1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      const projectionMatrix = new Float32Array(16);
      mat4Perspective(projectionMatrix, 45 * Math.PI / 180, 1.0, 0.1, 100.0);

      const modelViewMatrix = new Float32Array(16);
      mat4LookAt(modelViewMatrix, [1.5, 1, 5], [0.5, 0, 0], [0, 1, 0]);

      const rotationMatrix = new Float32Array(16);
      mat4RotateY(rotationMatrix, currentAngle);

      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
      gl.vertexAttribPointer(programInfo.attribLocations.position, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(programInfo.attribLocations.position);

      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
      gl.vertexAttribPointer(programInfo.attribLocations.color, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(programInfo.attribLocations.color);

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);

      gl.useProgram(programInfo.program);
      gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
      gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
      gl.uniformMatrix4fv(programInfo.uniformLocations.rotationMatrix, false, rotationMatrix);
      gl.uniform3fv(programInfo.uniformLocations.centroid, centroid);
      gl.uniform1i(programInfo.uniformLocations.useCentroid, useCentroid ? 1 : 0);

      gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
    }

    function animate() {
      angle += animationSpeed;

      if (angle >= Math.PI * 2) {
        angle = 0;
      }

      const degrees = Math.round((angle * 180 / Math.PI) % 360);
      document.getElementById('angleOrigin').textContent = degrees + '°';
      document.getElementById('angleCentroid').textContent = degrees + '°';

      drawScene(glOrigin, programOrigin, buffersOrigin, false, angle);
      drawScene(glCentroid, programCentroid, buffersCentroid, true, angle);

      requestAnimationFrame(animate);
    }

    function main() {
      const canvasOrigin = document.getElementById('canvasOrigin');
      glOrigin = initWebGL(canvasOrigin);
      if (!glOrigin) return;

      const shaderProgramOrigin = initShaderProgram(glOrigin, vsSource, fsSource);

      programOrigin = {
        program: shaderProgramOrigin,
        attribLocations: {
          position: glOrigin.getAttribLocation(shaderProgramOrigin, 'aPosition'),
          color: glOrigin.getAttribLocation(shaderProgramOrigin, 'aColor'),
        },
        uniformLocations: {
          projectionMatrix: glOrigin.getUniformLocation(shaderProgramOrigin, 'uProjectionMatrix'),
          modelViewMatrix: glOrigin.getUniformLocation(shaderProgramOrigin, 'uModelViewMatrix'),
          rotationMatrix: glOrigin.getUniformLocation(shaderProgramOrigin, 'uRotationMatrix'),
          centroid: glOrigin.getUniformLocation(shaderProgramOrigin, 'uCentroid'),
          useCentroid: glOrigin.getUniformLocation(shaderProgramOrigin, 'uUseCentroid'),
        },
      };

      buffersOrigin = initBuffers(glOrigin);

      const canvasCentroid = document.getElementById('canvasCentroid');
      glCentroid = initWebGL(canvasCentroid);
      if (!glCentroid) return;

      const shaderProgramCentroid = initShaderProgram(glCentroid, vsSource, fsSource);

      programCentroid = {
        program: shaderProgramCentroid,
        attribLocations: {
          position: glCentroid.getAttribLocation(shaderProgramCentroid, 'aPosition'),
          color: glCentroid.getAttribLocation(shaderProgramCentroid, 'aColor'),
        },
        uniformLocations: {
          projectionMatrix: glCentroid.getUniformLocation(shaderProgramCentroid, 'uProjectionMatrix'),
          modelViewMatrix: glCentroid.getUniformLocation(shaderProgramCentroid, 'uModelViewMatrix'),
          rotationMatrix: glCentroid.getUniformLocation(shaderProgramCentroid, 'uRotationMatrix'),
          centroid: glCentroid.getUniformLocation(shaderProgramCentroid, 'uCentroid'),
          useCentroid: glCentroid.getUniformLocation(shaderProgramCentroid, 'uUseCentroid'),
        },
      };

      buffersCentroid = initBuffers(glCentroid);

      animate();
    }

    window.onload = main;
  </script>
</body>
</html>
